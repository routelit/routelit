{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"routelit","text":"<p>routelit is a Python framework for building interactive web user interfaces that are framework-agnostic and easy to use. It allows you to create dynamic web applications with a simple, declarative API similar to Streamlit, but designed to work with any HTTP framework (Flask, FastAPI, Django, etc.).</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Framework Agnostic: Works with any Python web framework (Flask, FastAPI, Django, etc.)</li> <li>Declarative UI: Build interfaces using simple Python functions</li> <li>Interactive Components: Buttons, forms, inputs, selects, checkboxes, and more</li> <li>State Management: Built-in session state management</li> <li>Reactive Updates: Automatic UI updates based on user interactions</li> <li>Fragment Support: Partial page updates for better performance</li> <li>Flexible Layouts: Containers, columns, flex layouts, and expandable sections</li> <li>Rich Content: Support for markdown, images, and custom styling</li> </ul>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>Install routelit using pip:</p> <pre><code>pip install routelit\n# or\nuv add routelit\n</code></pre>"},{"location":"#quick-start","title":"\ud83d\udcd6 Quick Start","text":"<p>Here's a simple example of how to use routelit with Flask:</p> <pre><code>uv add routelit-flask\n</code></pre> <pre><code>from flask import Flask\nfrom routelit import RouteLit, RouteLitBuilder\nfrom routelit_flask import RouteLitFlaskAdapter\n\napp = Flask(__name__)\n\nrl = RouteLit()\nrl_adapter = RouteLitFlaskAdapter(rl).configure(app)\n\ndef index_view(rl: RouteLitBuilder):\n    rl.text(\"Hello, World!\")\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])\ndef index():\n    return rl_adapter.response(index_view)\n</code></pre>"},{"location":"modules/","title":"API Reference","text":""},{"location":"modules/#main-module","title":"Main Module","text":"<p>               Bases: <code>Generic[BuilderType]</code></p> <p>RouteLit is a class that provides a framework for handling HTTP requests and generating responses in a web application. It manages the routing and view functions that define how the application responds to different requests.</p> <p>The class maintains a registry of fragment functions and uses a builder pattern to construct responses. It supports both GET and POST requests, handling them differently based on the request method.</p> <p>Key features: - Session storage management - Fragment registry for reusable view components - Support for both GET and POST request handling - Builder pattern for constructing responses - Support for dependency injection in view functions</p> <p>The class is designed to be flexible, allowing for custom builder classes and session storage implementations.</p> Source code in <code>src/routelit/routelit.py</code> <pre><code>class RouteLit(Generic[BuilderType]):\n    \"\"\"\n    RouteLit is a class that provides a framework for handling HTTP requests and generating responses in a web application. It manages the routing and view functions that define how the application responds to different requests.\n\n    The class maintains a registry of fragment functions and uses a builder pattern to construct responses. It supports both GET and POST requests, handling them differently based on the request method.\n\n    Key features:\n    - Session storage management\n    - Fragment registry for reusable view components\n    - Support for both GET and POST request handling\n    - Builder pattern for constructing responses\n    - Support for dependency injection in view functions\n\n    The class is designed to be flexible, allowing for custom builder classes and session storage implementations.\n    \"\"\"\n\n    def __init__(\n        self,\n        BuilderClass: Type[BuilderType] = RouteLitBuilder,  # type: ignore[assignment]\n        session_storage: Optional[MutableMapping[str, Any]] = None,\n        cache_backend: Optional[MutableMapping[str, Any]] = None,\n        inject_builder: bool = True,\n        request_timeout: float = 60.0,  # timeout for the request to complete in seconds\n        importmap: Optional[Dict[str, Any]] = None,\n        extra_head_content: Optional[str] = None,\n        extra_body_content: Optional[str] = None,\n    ):\n        self.BuilderClass = BuilderClass\n        self.session_storage = session_storage or {}\n        self.cache_backend = cache_backend or {}\n        self.fragment_registry: Dict[str, Callable[[RouteLitBuilder], Any]] = {}\n        self._session_builder_context: contextvars.ContextVar[RouteLitBuilder] = contextvars.ContextVar(\n            \"session_builder\"\n        )\n        self.inject_builder = inject_builder\n        self.request_timeout = request_timeout\n        self.cancel_events: Dict[str, asyncio.Event] = {}\n        self.importmap = DEFAULT_JS_DEPENDENCIES if importmap is None else {**DEFAULT_JS_DEPENDENCIES, **importmap}\n        self.extra_head_content = extra_head_content\n        self.extra_body_content = extra_body_content\n\n    def get_extra_head_content(self) -&gt; str:\n        return self.extra_head_content or \"\"\n\n    def get_extra_body_content(self) -&gt; str:\n        return self.extra_body_content or \"\"\n\n    def get_importmap_json(self) -&gt; str:\n        return json.dumps({\"imports\": self.importmap}, indent=2)\n\n    @contextmanager\n    def _set_builder_context(self, builder: BuilderType) -&gt; Generator[BuilderType, None, None]:\n        \"\"\"\n        Temporarily expose the given builder instance through the\n        `self.ui` property using a ContextVar.\n\n        When this helper is used from multiple concurrent asyncio Tasks\n        (or when the code it wraps spawns background tasks / threads)\n        the logical *Context* in which the token was created can differ\n        from the one in which ``reset`` is executed.  In that case\n        ``ContextVar.reset`` raises ``ValueError`` with the message\n        \"Token was created in a different Context\".\n\n        This situation is benign for our use-case - the ContextVar has\n        already been cleared for the current logical flow - so we simply\n        suppress the error to prevent it from bubbling up and crashing the\n        request handler.\n        \"\"\"\n        token = self._session_builder_context.set(builder)\n        try:\n            yield builder\n        finally:\n            # ``reset`` fails if the context has diverged (e.g. different\n            # asyncio.Task or thread).  Silently ignore that situation.\n            with contextlib.suppress(ValueError):\n                self._session_builder_context.reset(token)\n\n    @property\n    def ui(self) -&gt; BuilderType:\n        \"\"\"\n        The current builder instance.\n        Use this in conjunction with `response(..., inject_builder=False)`\n        example:\n        ```python\n        rl = RouteLit()\n\n        def my_view():\n            rl.ui.text(\"Hello, world!\")\n\n        request = ...\n        response = rl.response(my_view, request, inject_builder=False)\n        ```\n        \"\"\"\n        return cast(BuilderType, self._session_builder_context.get())\n\n    def response(\n        self,\n        view_fn: ViewFn,\n        request: RouteLitRequest,\n        inject_builder: Optional[bool] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Union[RouteLitResponse, Dict[str, Any]]:\n        \"\"\"Handle the request and return the response.\n\n        Args:\n            view_fn (ViewFn): (Callable[[RouteLitBuilder], Any]) The view function to handle the request.\n            request (RouteLitRequest): The request object.\n            **kwargs (Dict[str, Any]): Additional keyword arguments.\n\n        Returns:\n            RouteLitResponse | Dict[str, Any]:\n                The response object.\n                where Dict[str, Any] is a dictionary that contains the following keys:\n                actions (List[Action]), target (Literal[\"app\", \"fragment\"])\n\n        Example:\n        ```python\n        from routelit import RouteLit, RouteLitBuilder\n\n        rl = RouteLit()\n\n        def my_view(rl: RouteLitBuilder):\n            rl.text(\"Hello, world!\")\n\n        request = ...\n        response = rl.response(my_view, request)\n\n        # example with dependency\n        def my_view(rl: RouteLitBuilder, name: str):\n            rl.text(f\"Hello, {name}!\")\n\n        request = ...\n        response = rl.response(my_view, request, name=\"John\")\n        ```\n        \"\"\"\n        if request.method == \"GET\":\n            return self.handle_get_request(view_fn, request, **kwargs)\n        elif request.method == \"POST\":\n            return self.handle_post_request(view_fn, request, inject_builder, *args, **kwargs)\n        else:\n            # set custom exception for unsupported request method\n            raise ValueError(request.method)\n\n    def handle_get_request(\n        self,\n        view_fn: ViewFn,\n        request: RouteLitRequest,\n        **kwargs: Any,\n    ) -&gt; RouteLitResponse:\n        \"\"\" \"\n        Handle a GET request.\n        If the session state is present, it will be cleared.\n        The head title and description can be passed as kwargs.\n        Example:\n        ```python\n        return routelit_adapter.response(build_signup_view, head_title=\"Signup\", head_description=\"Signup page\")\n        ```\n\n        Args:\n            request (RouteLitRequest): The request object.\n            **kwargs (Dict[str, Any]): Additional keyword arguments.\n                head_title (Optional[str]): The title of the head.\n                head_description (Optional[str]): The description of the head.\n\n        Returns:\n            RouteLitResponse: The response object.\n        \"\"\"\n        session_keys = request.get_session_keys()\n        (\n            ui_key,\n            state_key,\n            fragment_addresses_key,\n            fragment_params_key,\n            view_tasks_key,\n        ) = session_keys\n        view_tasks_key = build_view_task_key(view_fn, request.fragment_id, session_keys)\n        if view_tasks_key in self.cancel_events:\n            # send cancel event to the view task beforehand\n            self.cancel_events[view_tasks_key].set()\n\n        if state_key in self.session_storage:\n            self.session_storage.pop(ui_key, None)\n            self.session_storage.pop(state_key, None)\n            self.session_storage.pop(fragment_addresses_key, None)\n            self.session_storage.pop(fragment_params_key, None)\n        return RouteLitResponse(\n            elements=[],\n            head=Head(\n                title=kwargs.get(\"head_title\"),\n                description=kwargs.get(\"head_description\"),\n            ),\n        )\n\n    def _get_prev_keys(self, request: RouteLitRequest, session_keys: SessionKeys) -&gt; Tuple[bool, SessionKeys]:\n        maybe_event = request.ui_event\n        if maybe_event and maybe_event[\"type\"] == \"navigate\":\n            new_session_keys = request.get_session_keys(use_referer=True)\n            return True, new_session_keys\n        return False, session_keys\n\n    def _write_session_state(\n        self,\n        *,\n        session_keys: SessionKeys,\n        prev_root_element: RouteLitElement,\n        prev_fragments: MutableMapping[str, List[int]],\n        root_element: RouteLitElement,\n        session_state: MutableMapping[str, Any],\n        fragments: MutableMapping[str, List[int]],\n        fragment_id: Optional[str] = None,\n    ) -&gt; None:\n        if fragment_id and (fragment_address := prev_fragments.get(fragment_id, [])) and len(fragment_address) &gt; 0:\n            fragment_element = root_element\n            new_element = set_element_at_address(prev_root_element, fragment_address, fragment_element)\n        else:\n            new_element = root_element\n\n        ui_key, state_key, fragment_addresses_key, _, _vt = session_keys\n        self.session_storage[ui_key] = new_element\n        self.session_storage[state_key] = session_state\n        self.session_storage[fragment_addresses_key] = {**prev_fragments, **fragments}\n\n    def __write_session_state(\n        self,\n        session_keys: SessionKeys,\n        transition_params: BuilderTranstionParams,\n        builder: RouteLitBuilder,\n        fragment_id: Optional[str],\n    ) -&gt; None:\n        self._write_session_state(\n            session_keys=session_keys,\n            prev_root_element=transition_params.root_element,\n            prev_fragments=transition_params.fragments,\n            root_element=builder.root_element,\n            session_state=builder.session_state.get_data(),\n            fragments=builder.get_fragments(),\n            fragment_id=fragment_id,\n        )\n\n    def _get_prev_elements_at_fragment(\n        self,\n        session_keys: SessionKeys,\n        fragment_id: Optional[str],\n    ) -&gt; Tuple[RouteLitElement, Optional[RouteLitElement]]:\n        \"\"\"\n        Returns the previous elements of the full page and the previous elements of the fragment if address is provided.\n        \"\"\"\n        prev_root_element = self.session_storage.get(session_keys.ui_key, RouteLitElement.create_root_element())\n        if fragment_id:\n            fragment_address = self.session_storage.get(session_keys.fragment_addresses_key, {}).get(fragment_id, [])\n            fragment_element = get_element_at_address(prev_root_element, fragment_address)\n            return prev_root_element, fragment_element\n        return prev_root_element, None\n\n    def _handle_if_form_event(self, request: RouteLitRequest, session_keys: SessionKeys) -&gt; bool:\n        event = request.ui_event\n        if event and event.get(\"type\") != \"submit\" and (form_id := event.get(\"formId\")):\n            session_state = self.session_storage.get(session_keys.state_key, {})\n            events = session_state.get(f\"__events4later_{form_id}\", {})\n            events[event[\"componentId\"]] = event\n            self.session_storage[session_keys.state_key] = {\n                **session_state,\n                f\"__events4later_{form_id}\": events,\n            }\n            return True\n        return False\n\n    def _check_if_form_event(self, request: RouteLitRequest, session_keys: SessionKeys) -&gt; None:\n        if self._handle_if_form_event(request, session_keys):\n            raise EmptyReturnException()\n\n    def _handle_build_params(self, request: RouteLitRequest, session_keys: SessionKeys) -&gt; BuilderTranstionParams:\n        self._maybe_clear_session_state(request, session_keys)\n        is_navigation_event, prev_session_keys = self._get_prev_keys(request, session_keys)\n        prev_root_element, maybe_prev_fragment_element = self._get_prev_elements_at_fragment(\n            prev_session_keys, request.fragment_id\n        )\n        if is_navigation_event:\n            self._clear_session_state(prev_session_keys)\n        prev_session_state = self.session_storage.get(prev_session_keys.state_key, {})\n        prev_fragments = self.session_storage.get(prev_session_keys.fragment_addresses_key, {})\n        return BuilderTranstionParams(\n            root_element=prev_root_element,\n            maybe_fragment_element=maybe_prev_fragment_element,\n            session_state=prev_session_state,\n            fragments=prev_fragments,\n        )\n\n    @staticmethod\n    def _build_post_response(\n        prev_root_element: RouteLitElement,\n        root_element: RouteLitElement,\n        fragment_id: Optional[str],\n    ) -&gt; ActionsResponse:\n        target: Literal[\"app\", \"fragment\"] = \"app\" if fragment_id is None else \"fragment\"\n        actions = compare_single_elements(prev_root_element, root_element, target=target)\n        return ActionsResponse(actions=actions, target=target)\n\n    def _handle_builder_view_end(\n        self,\n        builder: RouteLitBuilder,\n        session_keys: SessionKeys,\n        transition_params: BuilderTranstionParams,\n        fragment_id: Optional[str],\n    ) -&gt; ActionsResponse:\n        self._write_session_state(\n            session_keys=session_keys,\n            prev_root_element=transition_params.root_element,\n            prev_fragments=transition_params.fragments,\n            root_element=builder.root_element,\n            session_state=builder.session_state.get_data(),\n            fragments=builder.get_fragments(),\n            fragment_id=fragment_id,\n        )\n        real_prev_root_element = transition_params.maybe_fragment_element or transition_params.root_element\n        return self._build_post_response(real_prev_root_element, builder.root_element, fragment_id)\n\n    def handle_post_request(\n        self,\n        view_fn: ViewFn,\n        request: RouteLitRequest,\n        inject_builder: Optional[bool] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Dict[str, Any]:\n        inject_builder = self.inject_builder if inject_builder is None else inject_builder\n        app_view_fn = view_fn\n        session_keys = request.get_session_keys()\n        try:\n            self._check_if_form_event(request, session_keys)\n            fragment_id = request.fragment_id\n            if fragment_id and fragment_id in self.fragment_registry:\n                view_fn = self.fragment_registry[fragment_id]\n            transition_params = self._handle_build_params(request, session_keys)\n            builder = self.BuilderClass(\n                request,\n                session_state=PropertyDict(transition_params.session_state),\n                fragments=transition_params.fragments,\n                initial_fragment_id=fragment_id,\n            )\n            new_args = (builder, *args) if inject_builder else args\n            with self._set_builder_context(builder):\n                view_fn(*new_args, **kwargs)\n            builder.on_end()\n            resp = self._handle_builder_view_end(builder, session_keys, transition_params, fragment_id)\n            return asdict(resp)\n        except RerunException as e:\n            self.session_storage[session_keys.state_key] = e.state\n            actual_view_fn = app_view_fn if e.scope == \"app\" else view_fn\n            return self.handle_post_request(actual_view_fn, request, inject_builder, *args, **kwargs)\n        except EmptyReturnException:\n            # No need to return anything\n            return asdict(ActionsResponse(actions=[], target=\"app\"))\n\n    async def _cancel_and_wait_view_task(self, view_task_key: str) -&gt; None:\n        \"\"\"Cancel the view task and wait for it to be cleaned up.\"\"\"\n        if view_task_key not in self.cancel_events:\n            return\n        self.cancel_events[view_task_key].set()\n        # Wait for cleanup\n        while view_task_key in self.cancel_events:\n            await asyncio.sleep(0.05)\n\n    async def handle_post_request_async_stream(\n        self,\n        view_fn: ViewFn,\n        request: RouteLitRequest,\n        inject_builder: Optional[bool] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; ActionGenerator:\n        inject_builder = self.inject_builder if inject_builder is None else inject_builder\n        app_view_fn = view_fn\n        session_keys = request.get_session_keys()\n        if self._handle_if_form_event(request, session_keys):\n            return  # no action needed\n        fragment_id = request.fragment_id\n        view_tasks_key = build_view_task_key(view_fn, fragment_id, session_keys)\n        # Maybe cancel any existing view tasks for this key and wait for cleanup\n        await self._cancel_and_wait_view_task(view_tasks_key)\n\n        if fragment_id and fragment_id in self.fragment_registry:\n            view_fn = self.fragment_registry[fragment_id]\n        transition_params = self._handle_build_params(request, session_keys)\n\n        loop = asyncio.get_running_loop()\n\n        async def run_view_process(\n            local_view_fn: ViewFn,\n            transition_params: BuilderTranstionParams,\n            local_fragment_id: Optional[str],\n        ) -&gt; ActionGenerator:\n            event_queue: asyncio.Queue[Action] = asyncio.Queue()\n            cancel_event = asyncio.Event()\n            self.cancel_events[view_tasks_key] = cancel_event\n            prev_root_element = transition_params.maybe_fragment_element or transition_params.root_element\n            builder = self.BuilderClass(\n                request,\n                session_state=PropertyDict(transition_params.session_state, cancel_event=cancel_event),\n                fragments=transition_params.fragments,\n                initial_fragment_id=local_fragment_id,\n                prev_root_element=prev_root_element,\n                event_queue=event_queue,\n                loop=loop,\n                cancel_event=cancel_event,\n                should_rerun_event=asyncio.Event(),\n            )\n            run_view_async = self._build_run_view_async(local_view_fn, builder, inject_builder, args, kwargs)\n            view_task = asyncio.create_task(run_view_async(), name=\"rl_view_fn\")\n            start_time = time.monotonic()\n\n            try:\n\n                def handle_view_task_done(task: asyncio.Task) -&gt; None:\n                    if task.done():\n                        with contextlib.suppress(asyncio.CancelledError, Exception):\n                            _ = task.exception()\n                    builder.handle_view_task_done()\n\n                view_task.add_done_callback(handle_view_task_done)\n                yield FreshBoundaryAction(\n                    address=[-1],\n                    target=\"app\" if local_fragment_id is None else \"fragment\",\n                )\n\n                while True:\n                    try:\n                        self._check_if_view_task_failed(view_task)\n                        if time.monotonic() - start_time &gt; self.request_timeout:\n                            raise StopException(\"View task timeout\")\n                        if cancel_event.is_set():\n                            await view_task  # should raise asyncio.CancelledError\n                            break\n                        action = await asyncio.wait_for(event_queue.get(), timeout=0.5)\n\n                        event_queue.task_done()\n                        if isinstance(action, Exception):\n                            raise action\n                        if isinstance(action, ViewTaskDoneAction):\n                            builder.on_end()\n                            continue\n                        if isinstance(action, RerunAction):\n                            raise RerunException(\n                                builder.session_state.get_data(),\n                                scope=action.target or \"app\",\n                            )\n                        yield action\n                        if isinstance(action, LastAction):\n                            break\n                    except asyncio.TimeoutError:\n                        # ignore on purpose small timeout from event_queue.get()\n                        pass\n                builder.on_end()\n                self.__write_session_state(session_keys, transition_params, builder, local_fragment_id)\n            except (StopException, asyncio.CancelledError):\n                self.__write_session_state(\n                    session_keys,\n                    transition_params,\n                    builder,\n                    local_fragment_id,\n                )\n            except EmptyReturnException:\n                # No need to return anything\n                pass\n            except RerunException as e:\n                (maybe_fragment_element, actual_view_fn, new_fragment_id) = (\n                    (None, app_view_fn, None)\n                    if e.scope == \"app\"\n                    else (\n                        transition_params.maybe_fragment_element,\n                        local_view_fn,\n                        local_fragment_id,\n                    )\n                )\n\n                _transition_params = BuilderTranstionParams(\n                    root_element=transition_params.root_element,\n                    maybe_fragment_element=maybe_fragment_element,\n                    session_state=e.state,\n                    fragments=builder.get_fragments(),\n                )\n                cancel_event.set()\n                await self._cancel_view_task(view_task)\n                async for action in run_view_process(\n                    actual_view_fn,\n                    _transition_params,\n                    new_fragment_id,\n                ):\n                    yield action\n            finally:\n                await self._cancel_view_task(view_task)\n                self.cancel_events.pop(view_tasks_key, None)\n\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", RuntimeWarning)\n            try:\n                async for action in run_view_process(view_fn, transition_params, fragment_id):\n                    yield action\n            except GeneratorExit:\n                print(\"\ud83d\udd0c HTTP connection closed by client\")\n                raise\n\n    async def handle_post_request_async_stream_jsonl(\n        self,\n        view_fn: ViewFn,\n        request: RouteLitRequest,\n        inject_builder: Optional[bool] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; AsyncGenerator[str, None]:\n        async_gen = self.handle_post_request_async_stream(view_fn, request, inject_builder, *args, **kwargs)\n        async for action in async_gen:\n            yield json.dumps(asdict(action), default=json_default) + \"\\n\"\n\n    def handle_post_request_stream_jsonl(\n        self,\n        view_fn: ViewFn,\n        request: RouteLitRequest,\n        inject_builder: Optional[bool] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Generator[str, None, None]:\n        async_gen = self.handle_post_request_async_stream(view_fn, request, inject_builder, *args, **kwargs)\n        for action in async_to_sync_generator(async_gen):\n            yield json.dumps(asdict(action), default=json_default) + \"\\n\"\n\n    def handle_post_request_stream(\n        self,\n        view_fn: ViewFn,\n        request: RouteLitRequest,\n        inject_builder: Optional[bool] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Generator[Action, None, None]:\n        async_gen = self.handle_post_request_async_stream(view_fn, request, inject_builder, *args, **kwargs)\n        yield from async_to_sync_generator(async_gen)\n\n    def get_builder_class(self) -&gt; Type[RouteLitBuilder]:\n        return self.BuilderClass\n\n    def _clear_session_state(self, session_keys: SessionKeys) -&gt; None:\n        self.session_storage.pop(session_keys.state_key, None)\n        self.session_storage.pop(session_keys.ui_key, None)\n        self.session_storage.pop(session_keys.fragment_addresses_key, None)\n        self.session_storage.pop(session_keys.fragment_params_key, None)\n\n    def _maybe_clear_session_state(self, request: RouteLitRequest, session_keys: SessionKeys) -&gt; None:\n        if request.get_query_param(\"__routelit_clear_session_state\"):\n            self._clear_session_state(session_keys)\n            raise EmptyReturnException()\n\n    def client_assets(self) -&gt; List[ViteComponentsAssets]:\n        \"\"\"\n        Render the vite assets for BuilderClass components.\n        This function will return a list of ViteComponentsAssets.\n        This should be called by the web framework to render the assets.\n        \"\"\"\n        assets = []\n        for static_path in self.BuilderClass.get_client_resource_paths():\n            vite_assets = get_vite_components_assets(static_path[\"package_name\"])\n            assets.append(vite_assets)\n\n        return assets\n\n    def default_client_assets(self) -&gt; ViteComponentsAssets:\n        return get_vite_components_assets(\"routelit\")\n\n    def _register_fragment(self, key: str, fragment: Callable[[RouteLitBuilder], Any]) -&gt; None:\n        self.fragment_registry[key] = fragment\n\n    def _preprocess_fragment_params(\n        self, fragment_key: str, args: Tuple[Any, ...], kwargs: Dict[str, Any]\n    ) -&gt; Tuple[BuilderType, bool, Tuple[Any, ...], Dict[str, Any]]:\n        is_builder_1st_arg = args is not None and len(args) &gt; 0 and isinstance(args[0], RouteLitBuilder)\n        rl: BuilderType = cast(RouteLitBuilder, args[0]) if is_builder_1st_arg else self.ui  # type: ignore[assignment]\n        if is_builder_1st_arg:\n            args = args[1:]\n        is_fragment_request = rl.request.fragment_id is not None\n        session_keys = rl.request.get_session_keys()\n        if not is_fragment_request:\n            fragment_params_by_key = {\n                fragment_key: {\n                    \"args\": args,\n                    \"kwargs\": kwargs,\n                }\n            }\n            all_fragment_params = self.session_storage.get(session_keys.fragment_params_key, {})\n            self.session_storage[session_keys.fragment_params_key] = {\n                **all_fragment_params,\n                **fragment_params_by_key,\n            }\n        else:\n            fragment_params = self.session_storage.get(session_keys.fragment_params_key, {}).get(fragment_key, {})\n            args = fragment_params.get(\"args\", [])\n            kwargs = fragment_params.get(\"kwargs\", {})\n\n        return rl, is_builder_1st_arg, args, kwargs\n\n    def fragment(self, key: Optional[str] = None) -&gt; Callable[[ViewFn], ViewFn]:\n        \"\"\"\n        Decorator to register a fragment.\n\n        Args:\n            key: The key to register the fragment with.\n\n        Returns:\n            The decorator function.\n\n        Example:\n        ```python\n        from routelit import RouteLit, RouteLitBuilder\n\n        rl = RouteLit()\n\n        @rl.fragment()\n        def my_fragment(ui: RouteLitBuilder):\n            ui.text(\"Hello, world!\")\n\n        @rl.fragment()\n        def my_fragment2():\n            ui = rl.ui\n            ui.text(\"Hello, world!\")\n        ```\n        \"\"\"\n\n        def decorator_fragment(view_fn: ViewFn) -&gt; ViewFn:\n            fragment_key = key or view_fn.__name__\n\n            @functools.wraps(view_fn)\n            def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                rl, is_builder_1st_arg, args, kwargs = self._preprocess_fragment_params(fragment_key, args, kwargs)\n\n                with rl._fragment(fragment_key):\n                    res = view_fn(rl, *args, **kwargs) if is_builder_1st_arg else view_fn(*args, **kwargs)\n                    return res\n\n            self._register_fragment(fragment_key, wrapper)\n            return wrapper\n\n        return decorator_fragment\n\n    def _x_overlay_decor(\n        self,\n        builder_fn: Callable[[RouteLitBuilder], Callable[..., RouteLitBuilder]],\n        overlay_type: str = \"dialog\",\n    ) -&gt; Callable[..., Callable[[ViewFn], ViewFn]]:\n        def overlay_decor(*args: Any, **kwargs: Any) -&gt; Callable[[ViewFn], ViewFn]:\n            def decorator_overlay(view_fn: ViewFn) -&gt; ViewFn:\n                key = args[0] if len(args) &gt; 0 else None\n                fragment_key = key if isinstance(key, str) else view_fn.__name__\n                overlay_key = f\"{fragment_key}-{overlay_type}\"\n                overlay_upper_kwargs = kwargs\n\n                @functools.wraps(view_fn)\n                def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                    rl, is_builder_1st_arg, args, kwargs = self._preprocess_fragment_params(fragment_key, args, kwargs)\n                    with rl._fragment(fragment_key), builder_fn(rl)(overlay_key, **overlay_upper_kwargs):\n                        res = view_fn(rl, *args, **kwargs) if is_builder_1st_arg else view_fn(*args, **kwargs)\n                        return res\n\n                self._register_fragment(fragment_key, wrapper)\n                return wrapper\n\n            return decorator_overlay\n\n        return overlay_decor\n\n    def _x_dialog_decor(\n        self,\n        builder_fn: Callable[[RouteLitBuilder], Callable[..., RouteLitBuilder]],\n    ) -&gt; Callable[..., Callable[[ViewFn], ViewFn]]:\n        \"\"\"Backward compatibility wrapper for _x_overlay_decor with dialog type.\"\"\"\n        return self._x_overlay_decor(builder_fn, overlay_type=\"dialog\")\n\n    def dialog(self, key: Optional[str] = None, **kwargs: Any) -&gt; Callable[[ViewFn], ViewFn]:\n        \"\"\"Decorator to register a dialog.\n\n        Args:\n            key (Optional[str]): The key to register the dialog with.\n\n        Returns:\n            The decorator function.\n\n        Example:\n        ```python\n        from routelit import RouteLit, RouteLitBuilder\n\n        rl = RouteLit()\n\n        @rl.dialog()\n        def my_dialog(ui: RouteLitBuilder):\n            ui.text(\"Hello, world!\")\n\n        def my_main_view(ui: RouteLitBuilder):\n            if ui.button(\"Open dialog\"):\n                my_dialog(ui)\n\n        @rl.dialog()\n        def my_dialog2():\n            ui = rl.ui\n            ui.text(\"Hello, world!\")\n\n        def my_main_view2():\n            ui = rl.ui\n            if ui.button(\"Open dialog\"):\n                my_dialog2()\n        ```\n        \"\"\"\n\n        def dialog_builder(\n            rl: RouteLitBuilder,\n        ) -&gt; Callable[..., RouteLitBuilder]:\n            return rl._dialog\n\n        return self._x_dialog_decor(dialog_builder)(key, **kwargs)\n\n    def create_overlay_decorator(\n        self, overlay_type: str, builder_method_name: Optional[str] = None\n    ) -&gt; Callable[..., Callable[[ViewFn], ViewFn]]:\n        \"\"\"Generic method to create custom overlay decorators.\n\n        Args:\n            overlay_type (str): The type of overlay (e.g., \"popup\", \"sidebar\", \"sheet\", etc.)\n            builder_method_name (Optional[str]): The name of the builder method to use. Defaults to overlay_type or \"_dialog\"\n\n        Returns:\n            A decorator function for the specified overlay type.\n\n        Example:\n        ```python\n        rl = RouteLit()\n\n        # Create a custom overlay decorator\n        popup = rl.create_overlay_decorator(\"popup\", \"popup\")\n        sheet = rl.create_overlay_decorator(\"sheet\", \"drawer\")  # Use drawer method for sheet\n\n        @popup()\n        def my_popup(ui: RouteLitBuilder):\n            ui.text(\"Hello from popup!\")\n\n        @sheet()\n        def my_sheet(ui: RouteLitBuilder):\n            ui.text(\"Hello from sheet!\")\n        ```\n        \"\"\"\n\n        def overlay_decorator(key: Optional[str] = None, **kwargs: Any) -&gt; Callable[[ViewFn], ViewFn]:\n            def overlay_builder(\n                rl: RouteLitBuilder,\n            ) -&gt; Callable[..., RouteLitBuilder]:\n                method_name = builder_method_name or overlay_type\n                if hasattr(rl, method_name):\n                    return getattr(rl, method_name)  # type: ignore[no-any-return]\n                else:\n                    # Fallback to _dialog method\n                    return rl._dialog\n\n            return self._x_overlay_decor(overlay_builder, overlay_type=overlay_type)(key, **kwargs)\n\n        return overlay_decorator\n\n    def _build_run_view_async(\n        self,\n        view_fn: Callable[[RouteLitBuilder], Union[None, Awaitable[None]]],\n        builder: BuilderType,\n        inject_builder: bool,\n        args: Tuple[Any, ...],\n        kwargs: Dict[Any, Any],\n    ) -&gt; Callable[[], Coroutine[Any, Any, None]]:\n        async def run_view_async() -&gt; None:\n            new_args = (builder, *args) if inject_builder else args\n            with self._set_builder_context(builder):\n                coro = (\n                    view_fn(*new_args, **kwargs)\n                    if asyncio.iscoroutinefunction(view_fn)\n                    else asyncio.to_thread(view_fn, *new_args, **kwargs)\n                )\n                await coro\n\n        return run_view_async\n\n    def cache_data(\n        self, func: Optional[Callable[..., Any]] = None\n    ) -&gt; Union[Callable[[Callable[..., Any]], Callable[..., Any]], Callable[..., Any]]:\n        \"\"\"\n        Decorator to cache function results based on input parameters.\n        Parameters starting with underscore are excluded from cache key generation.\n        Supports both synchronous and asynchronous functions.\n\n        Can be used with or without parentheses:\n        @rl.cache_data() or @rl.cache_data\n\n        Args:\n            func: The function to be decorated (when used without parentheses)\n\n        Returns:\n            The decorated function that caches its results\n\n        Example:\n            ```python\n            rl = RouteLit()\n\n            @rl.cache_data()\n            def expensive_computation(x, y, _debug=False):\n                return x + y  # _debug parameter is excluded from cache key\n\n            @rl.cache_data  # Also works without parentheses\n            def another_function(a, b, _internal=None):\n                return a * b\n\n            @rl.cache_data()\n            async def async_computation(x, y, _debug=False):\n                return x + y  # Works with async functions too\n\n            # First call will execute the function\n            result1 = expensive_computation(1, 2, _debug=True)\n\n            # Second call with same x, y but different _debug will return cached result\n            result2 = expensive_computation(1, 2, _debug=False)  # Returns cached result\n\n            # Call with different x, y will execute function again\n            result3 = expensive_computation(2, 3, _debug=True)  # Executes function\n\n            # Async functions work the same way\n            result4 = await async_computation(1, 2, _debug=True)\n            result5 = await async_computation(1, 2, _debug=False)  # Returns cached result\n            ```\n        \"\"\"\n\n        def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n            # Check if the function is async\n            is_async = inspect.iscoroutinefunction(func)\n\n            def _get_cache_key(*args: Any, **kwargs: Any) -&gt; str:\n                \"\"\"Helper function to generate cache key from arguments.\"\"\"\n                # Get function signature to identify parameter names\n                sig = inspect.signature(func)\n                bound_args = sig.bind(*args, **kwargs)\n                bound_args.apply_defaults()\n\n                # Filter out parameters that start with underscore\n                cache_params = {}\n                for param_name, param_value in bound_args.arguments.items():\n                    if not param_name.startswith(\"_\"):\n                        cache_params[param_name] = param_value\n\n                # Generate cache key from function name and filtered parameters\n                cache_key_data = {\"func_name\": func.__name__, \"params\": cache_params}\n                return hashlib.md5(json.dumps(cache_key_data, sort_keys=True, default=str).encode()).hexdigest()  # noqa: S324; type: ignore[hashlib-insecure-hash-function]\n\n            if is_async:\n\n                @functools.wraps(func)\n                async def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                    cache_key = _get_cache_key(*args, **kwargs)\n\n                    # Check if result is already cached\n                    if cache_key in self.cache_backend:\n                        return self.cache_backend[cache_key]\n\n                    # Execute async function and cache result\n                    result = await func(*args, **kwargs)\n                    self.cache_backend[cache_key] = result\n                    return result\n\n                return async_wrapper\n            else:\n\n                @functools.wraps(func)\n                def sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                    cache_key = _get_cache_key(*args, **kwargs)\n\n                    # Check if result is already cached\n                    if cache_key in self.cache_backend:\n                        return self.cache_backend[cache_key]\n\n                    # Execute function and cache result\n                    result = func(*args, **kwargs)\n                    self.cache_backend[cache_key] = result\n                    return result\n\n                return sync_wrapper\n\n        # Handle both @cache_data and @cache_data() usage patterns\n        if func is None:\n            return decorator\n        else:\n            return decorator(func)\n\n    @staticmethod\n    def _check_if_view_task_failed(view_task: asyncio.Task) -&gt; None:\n        if view_task.done() and view_task.exception() is not None:\n            exception = view_task.exception()\n            raise exception  # type: ignore[misc]\n\n    @staticmethod\n    async def _cancel_view_task(\n        view_task: asyncio.Task, timeout: float = 2.0, suppress_cancel_error: bool = True\n    ) -&gt; None:\n        if not view_task.done():\n            view_task.cancel()\n            if suppress_cancel_error:\n                with contextlib.suppress(asyncio.CancelledError):\n                    await asyncio.wait_for(view_task, timeout=timeout)\n            else:\n                await asyncio.wait_for(view_task, timeout=timeout)\n</code></pre>"},{"location":"modules/#routelit.RouteLit.ui","title":"<code>ui</code>  <code>property</code>","text":"<p>The current builder instance. Use this in conjunction with <code>response(..., inject_builder=False)</code> example:</p> <pre><code>rl = RouteLit()\n\ndef my_view():\n    rl.ui.text(\"Hello, world!\")\n\nrequest = ...\nresponse = rl.response(my_view, request, inject_builder=False)\n</code></pre>"},{"location":"modules/#routelit.RouteLit.cache_data","title":"<code>cache_data(func=None)</code>","text":"<p>Decorator to cache function results based on input parameters. Parameters starting with underscore are excluded from cache key generation. Supports both synchronous and asynchronous functions.</p> <p>Can be used with or without parentheses: @rl.cache_data() or @rl.cache_data</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable[..., Any]]</code> <p>The function to be decorated (when used without parentheses)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Callable[[Callable[..., Any]], Callable[..., Any]], Callable[..., Any]]</code> <p>The decorated function that caches its results</p> Example <pre><code>rl = RouteLit()\n\n@rl.cache_data()\ndef expensive_computation(x, y, _debug=False):\n    return x + y  # _debug parameter is excluded from cache key\n\n@rl.cache_data  # Also works without parentheses\ndef another_function(a, b, _internal=None):\n    return a * b\n\n@rl.cache_data()\nasync def async_computation(x, y, _debug=False):\n    return x + y  # Works with async functions too\n\n# First call will execute the function\nresult1 = expensive_computation(1, 2, _debug=True)\n\n# Second call with same x, y but different _debug will return cached result\nresult2 = expensive_computation(1, 2, _debug=False)  # Returns cached result\n\n# Call with different x, y will execute function again\nresult3 = expensive_computation(2, 3, _debug=True)  # Executes function\n\n# Async functions work the same way\nresult4 = await async_computation(1, 2, _debug=True)\nresult5 = await async_computation(1, 2, _debug=False)  # Returns cached result\n</code></pre> Source code in <code>src/routelit/routelit.py</code> <pre><code>def cache_data(\n    self, func: Optional[Callable[..., Any]] = None\n) -&gt; Union[Callable[[Callable[..., Any]], Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Decorator to cache function results based on input parameters.\n    Parameters starting with underscore are excluded from cache key generation.\n    Supports both synchronous and asynchronous functions.\n\n    Can be used with or without parentheses:\n    @rl.cache_data() or @rl.cache_data\n\n    Args:\n        func: The function to be decorated (when used without parentheses)\n\n    Returns:\n        The decorated function that caches its results\n\n    Example:\n        ```python\n        rl = RouteLit()\n\n        @rl.cache_data()\n        def expensive_computation(x, y, _debug=False):\n            return x + y  # _debug parameter is excluded from cache key\n\n        @rl.cache_data  # Also works without parentheses\n        def another_function(a, b, _internal=None):\n            return a * b\n\n        @rl.cache_data()\n        async def async_computation(x, y, _debug=False):\n            return x + y  # Works with async functions too\n\n        # First call will execute the function\n        result1 = expensive_computation(1, 2, _debug=True)\n\n        # Second call with same x, y but different _debug will return cached result\n        result2 = expensive_computation(1, 2, _debug=False)  # Returns cached result\n\n        # Call with different x, y will execute function again\n        result3 = expensive_computation(2, 3, _debug=True)  # Executes function\n\n        # Async functions work the same way\n        result4 = await async_computation(1, 2, _debug=True)\n        result5 = await async_computation(1, 2, _debug=False)  # Returns cached result\n        ```\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        # Check if the function is async\n        is_async = inspect.iscoroutinefunction(func)\n\n        def _get_cache_key(*args: Any, **kwargs: Any) -&gt; str:\n            \"\"\"Helper function to generate cache key from arguments.\"\"\"\n            # Get function signature to identify parameter names\n            sig = inspect.signature(func)\n            bound_args = sig.bind(*args, **kwargs)\n            bound_args.apply_defaults()\n\n            # Filter out parameters that start with underscore\n            cache_params = {}\n            for param_name, param_value in bound_args.arguments.items():\n                if not param_name.startswith(\"_\"):\n                    cache_params[param_name] = param_value\n\n            # Generate cache key from function name and filtered parameters\n            cache_key_data = {\"func_name\": func.__name__, \"params\": cache_params}\n            return hashlib.md5(json.dumps(cache_key_data, sort_keys=True, default=str).encode()).hexdigest()  # noqa: S324; type: ignore[hashlib-insecure-hash-function]\n\n        if is_async:\n\n            @functools.wraps(func)\n            async def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                cache_key = _get_cache_key(*args, **kwargs)\n\n                # Check if result is already cached\n                if cache_key in self.cache_backend:\n                    return self.cache_backend[cache_key]\n\n                # Execute async function and cache result\n                result = await func(*args, **kwargs)\n                self.cache_backend[cache_key] = result\n                return result\n\n            return async_wrapper\n        else:\n\n            @functools.wraps(func)\n            def sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n                cache_key = _get_cache_key(*args, **kwargs)\n\n                # Check if result is already cached\n                if cache_key in self.cache_backend:\n                    return self.cache_backend[cache_key]\n\n                # Execute function and cache result\n                result = func(*args, **kwargs)\n                self.cache_backend[cache_key] = result\n                return result\n\n            return sync_wrapper\n\n    # Handle both @cache_data and @cache_data() usage patterns\n    if func is None:\n        return decorator\n    else:\n        return decorator(func)\n</code></pre>"},{"location":"modules/#routelit.RouteLit.client_assets","title":"<code>client_assets()</code>","text":"<p>Render the vite assets for BuilderClass components. This function will return a list of ViteComponentsAssets. This should be called by the web framework to render the assets.</p> Source code in <code>src/routelit/routelit.py</code> <pre><code>def client_assets(self) -&gt; List[ViteComponentsAssets]:\n    \"\"\"\n    Render the vite assets for BuilderClass components.\n    This function will return a list of ViteComponentsAssets.\n    This should be called by the web framework to render the assets.\n    \"\"\"\n    assets = []\n    for static_path in self.BuilderClass.get_client_resource_paths():\n        vite_assets = get_vite_components_assets(static_path[\"package_name\"])\n        assets.append(vite_assets)\n\n    return assets\n</code></pre>"},{"location":"modules/#routelit.RouteLit.create_overlay_decorator","title":"<code>create_overlay_decorator(overlay_type, builder_method_name=None)</code>","text":"<p>Generic method to create custom overlay decorators.</p> <p>Parameters:</p> Name Type Description Default <code>overlay_type</code> <code>str</code> <p>The type of overlay (e.g., \"popup\", \"sidebar\", \"sheet\", etc.)</p> required <code>builder_method_name</code> <code>Optional[str]</code> <p>The name of the builder method to use. Defaults to overlay_type or \"_dialog\"</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[..., Callable[[ViewFn], ViewFn]]</code> <p>A decorator function for the specified overlay type.</p> <p>Example:</p> <pre><code>rl = RouteLit()\n\n# Create a custom overlay decorator\npopup = rl.create_overlay_decorator(\"popup\", \"popup\")\nsheet = rl.create_overlay_decorator(\"sheet\", \"drawer\")  # Use drawer method for sheet\n\n@popup()\ndef my_popup(ui: RouteLitBuilder):\n    ui.text(\"Hello from popup!\")\n\n@sheet()\ndef my_sheet(ui: RouteLitBuilder):\n    ui.text(\"Hello from sheet!\")\n</code></pre> Source code in <code>src/routelit/routelit.py</code> <pre><code>def create_overlay_decorator(\n    self, overlay_type: str, builder_method_name: Optional[str] = None\n) -&gt; Callable[..., Callable[[ViewFn], ViewFn]]:\n    \"\"\"Generic method to create custom overlay decorators.\n\n    Args:\n        overlay_type (str): The type of overlay (e.g., \"popup\", \"sidebar\", \"sheet\", etc.)\n        builder_method_name (Optional[str]): The name of the builder method to use. Defaults to overlay_type or \"_dialog\"\n\n    Returns:\n        A decorator function for the specified overlay type.\n\n    Example:\n    ```python\n    rl = RouteLit()\n\n    # Create a custom overlay decorator\n    popup = rl.create_overlay_decorator(\"popup\", \"popup\")\n    sheet = rl.create_overlay_decorator(\"sheet\", \"drawer\")  # Use drawer method for sheet\n\n    @popup()\n    def my_popup(ui: RouteLitBuilder):\n        ui.text(\"Hello from popup!\")\n\n    @sheet()\n    def my_sheet(ui: RouteLitBuilder):\n        ui.text(\"Hello from sheet!\")\n    ```\n    \"\"\"\n\n    def overlay_decorator(key: Optional[str] = None, **kwargs: Any) -&gt; Callable[[ViewFn], ViewFn]:\n        def overlay_builder(\n            rl: RouteLitBuilder,\n        ) -&gt; Callable[..., RouteLitBuilder]:\n            method_name = builder_method_name or overlay_type\n            if hasattr(rl, method_name):\n                return getattr(rl, method_name)  # type: ignore[no-any-return]\n            else:\n                # Fallback to _dialog method\n                return rl._dialog\n\n        return self._x_overlay_decor(overlay_builder, overlay_type=overlay_type)(key, **kwargs)\n\n    return overlay_decorator\n</code></pre>"},{"location":"modules/#routelit.RouteLit.dialog","title":"<code>dialog(key=None, **kwargs)</code>","text":"<p>Decorator to register a dialog.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>The key to register the dialog with.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[ViewFn], ViewFn]</code> <p>The decorator function.</p> <p>Example:</p> <pre><code>from routelit import RouteLit, RouteLitBuilder\n\nrl = RouteLit()\n\n@rl.dialog()\ndef my_dialog(ui: RouteLitBuilder):\n    ui.text(\"Hello, world!\")\n\ndef my_main_view(ui: RouteLitBuilder):\n    if ui.button(\"Open dialog\"):\n        my_dialog(ui)\n\n@rl.dialog()\ndef my_dialog2():\n    ui = rl.ui\n    ui.text(\"Hello, world!\")\n\ndef my_main_view2():\n    ui = rl.ui\n    if ui.button(\"Open dialog\"):\n        my_dialog2()\n</code></pre> Source code in <code>src/routelit/routelit.py</code> <pre><code>def dialog(self, key: Optional[str] = None, **kwargs: Any) -&gt; Callable[[ViewFn], ViewFn]:\n    \"\"\"Decorator to register a dialog.\n\n    Args:\n        key (Optional[str]): The key to register the dialog with.\n\n    Returns:\n        The decorator function.\n\n    Example:\n    ```python\n    from routelit import RouteLit, RouteLitBuilder\n\n    rl = RouteLit()\n\n    @rl.dialog()\n    def my_dialog(ui: RouteLitBuilder):\n        ui.text(\"Hello, world!\")\n\n    def my_main_view(ui: RouteLitBuilder):\n        if ui.button(\"Open dialog\"):\n            my_dialog(ui)\n\n    @rl.dialog()\n    def my_dialog2():\n        ui = rl.ui\n        ui.text(\"Hello, world!\")\n\n    def my_main_view2():\n        ui = rl.ui\n        if ui.button(\"Open dialog\"):\n            my_dialog2()\n    ```\n    \"\"\"\n\n    def dialog_builder(\n        rl: RouteLitBuilder,\n    ) -&gt; Callable[..., RouteLitBuilder]:\n        return rl._dialog\n\n    return self._x_dialog_decor(dialog_builder)(key, **kwargs)\n</code></pre>"},{"location":"modules/#routelit.RouteLit.fragment","title":"<code>fragment(key=None)</code>","text":"<p>Decorator to register a fragment.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>The key to register the fragment with.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[ViewFn], ViewFn]</code> <p>The decorator function.</p> <p>Example:</p> <pre><code>from routelit import RouteLit, RouteLitBuilder\n\nrl = RouteLit()\n\n@rl.fragment()\ndef my_fragment(ui: RouteLitBuilder):\n    ui.text(\"Hello, world!\")\n\n@rl.fragment()\ndef my_fragment2():\n    ui = rl.ui\n    ui.text(\"Hello, world!\")\n</code></pre> Source code in <code>src/routelit/routelit.py</code> <pre><code>def fragment(self, key: Optional[str] = None) -&gt; Callable[[ViewFn], ViewFn]:\n    \"\"\"\n    Decorator to register a fragment.\n\n    Args:\n        key: The key to register the fragment with.\n\n    Returns:\n        The decorator function.\n\n    Example:\n    ```python\n    from routelit import RouteLit, RouteLitBuilder\n\n    rl = RouteLit()\n\n    @rl.fragment()\n    def my_fragment(ui: RouteLitBuilder):\n        ui.text(\"Hello, world!\")\n\n    @rl.fragment()\n    def my_fragment2():\n        ui = rl.ui\n        ui.text(\"Hello, world!\")\n    ```\n    \"\"\"\n\n    def decorator_fragment(view_fn: ViewFn) -&gt; ViewFn:\n        fragment_key = key or view_fn.__name__\n\n        @functools.wraps(view_fn)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            rl, is_builder_1st_arg, args, kwargs = self._preprocess_fragment_params(fragment_key, args, kwargs)\n\n            with rl._fragment(fragment_key):\n                res = view_fn(rl, *args, **kwargs) if is_builder_1st_arg else view_fn(*args, **kwargs)\n                return res\n\n        self._register_fragment(fragment_key, wrapper)\n        return wrapper\n\n    return decorator_fragment\n</code></pre>"},{"location":"modules/#routelit.RouteLit.handle_get_request","title":"<code>handle_get_request(view_fn, request, **kwargs)</code>","text":"<p>\" Handle a GET request. If the session state is present, it will be cleared. The head title and description can be passed as kwargs. Example:</p> <pre><code>return routelit_adapter.response(build_signup_view, head_title=\"Signup\", head_description=\"Signup page\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>RouteLitRequest</code> <p>The request object.</p> required <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments. head_title (Optional[str]): The title of the head. head_description (Optional[str]): The description of the head.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>RouteLitResponse</code> <code>RouteLitResponse</code> <p>The response object.</p> Source code in <code>src/routelit/routelit.py</code> <pre><code>def handle_get_request(\n    self,\n    view_fn: ViewFn,\n    request: RouteLitRequest,\n    **kwargs: Any,\n) -&gt; RouteLitResponse:\n    \"\"\" \"\n    Handle a GET request.\n    If the session state is present, it will be cleared.\n    The head title and description can be passed as kwargs.\n    Example:\n    ```python\n    return routelit_adapter.response(build_signup_view, head_title=\"Signup\", head_description=\"Signup page\")\n    ```\n\n    Args:\n        request (RouteLitRequest): The request object.\n        **kwargs (Dict[str, Any]): Additional keyword arguments.\n            head_title (Optional[str]): The title of the head.\n            head_description (Optional[str]): The description of the head.\n\n    Returns:\n        RouteLitResponse: The response object.\n    \"\"\"\n    session_keys = request.get_session_keys()\n    (\n        ui_key,\n        state_key,\n        fragment_addresses_key,\n        fragment_params_key,\n        view_tasks_key,\n    ) = session_keys\n    view_tasks_key = build_view_task_key(view_fn, request.fragment_id, session_keys)\n    if view_tasks_key in self.cancel_events:\n        # send cancel event to the view task beforehand\n        self.cancel_events[view_tasks_key].set()\n\n    if state_key in self.session_storage:\n        self.session_storage.pop(ui_key, None)\n        self.session_storage.pop(state_key, None)\n        self.session_storage.pop(fragment_addresses_key, None)\n        self.session_storage.pop(fragment_params_key, None)\n    return RouteLitResponse(\n        elements=[],\n        head=Head(\n            title=kwargs.get(\"head_title\"),\n            description=kwargs.get(\"head_description\"),\n        ),\n    )\n</code></pre>"},{"location":"modules/#routelit.RouteLit.response","title":"<code>response(view_fn, request, inject_builder=None, *args, **kwargs)</code>","text":"<p>Handle the request and return the response.</p> <p>Parameters:</p> Name Type Description Default <code>view_fn</code> <code>ViewFn</code> <p>(Callable[[RouteLitBuilder], Any]) The view function to handle the request.</p> required <code>request</code> <code>RouteLitRequest</code> <p>The request object.</p> required <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[RouteLitResponse, Dict[str, Any]]</code> <p>RouteLitResponse | Dict[str, Any]: The response object. where Dict[str, Any] is a dictionary that contains the following keys: actions (List[Action]), target (Literal[\"app\", \"fragment\"])</p> <p>Example:</p> <pre><code>from routelit import RouteLit, RouteLitBuilder\n\nrl = RouteLit()\n\ndef my_view(rl: RouteLitBuilder):\n    rl.text(\"Hello, world!\")\n\nrequest = ...\nresponse = rl.response(my_view, request)\n\n# example with dependency\ndef my_view(rl: RouteLitBuilder, name: str):\n    rl.text(f\"Hello, {name}!\")\n\nrequest = ...\nresponse = rl.response(my_view, request, name=\"John\")\n</code></pre> Source code in <code>src/routelit/routelit.py</code> <pre><code>def response(\n    self,\n    view_fn: ViewFn,\n    request: RouteLitRequest,\n    inject_builder: Optional[bool] = None,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Union[RouteLitResponse, Dict[str, Any]]:\n    \"\"\"Handle the request and return the response.\n\n    Args:\n        view_fn (ViewFn): (Callable[[RouteLitBuilder], Any]) The view function to handle the request.\n        request (RouteLitRequest): The request object.\n        **kwargs (Dict[str, Any]): Additional keyword arguments.\n\n    Returns:\n        RouteLitResponse | Dict[str, Any]:\n            The response object.\n            where Dict[str, Any] is a dictionary that contains the following keys:\n            actions (List[Action]), target (Literal[\"app\", \"fragment\"])\n\n    Example:\n    ```python\n    from routelit import RouteLit, RouteLitBuilder\n\n    rl = RouteLit()\n\n    def my_view(rl: RouteLitBuilder):\n        rl.text(\"Hello, world!\")\n\n    request = ...\n    response = rl.response(my_view, request)\n\n    # example with dependency\n    def my_view(rl: RouteLitBuilder, name: str):\n        rl.text(f\"Hello, {name}!\")\n\n    request = ...\n    response = rl.response(my_view, request, name=\"John\")\n    ```\n    \"\"\"\n    if request.method == \"GET\":\n        return self.handle_get_request(view_fn, request, **kwargs)\n    elif request.method == \"POST\":\n        return self.handle_post_request(view_fn, request, inject_builder, *args, **kwargs)\n    else:\n        # set custom exception for unsupported request method\n        raise ValueError(request.method)\n</code></pre>"},{"location":"modules/#builder-module","title":"Builder Module","text":""},{"location":"modules/#routelit.builder.ColumnsGap","title":"<code>ColumnsGap = Literal['none', 'small', 'medium', 'large']</code>  <code>module-attribute</code>","text":"<p>The gap between the columns.</p>"},{"location":"modules/#routelit.builder.TextInputType","title":"<code>TextInputType = Literal['text', 'number', 'email', 'password', 'search', 'tel', 'url', 'date', 'time', 'datetime-local', 'month', 'week']</code>  <code>module-attribute</code>","text":"<p>The type of the text input.</p>"},{"location":"modules/#routelit.builder.VerticalAlignment","title":"<code>VerticalAlignment = Literal['top', 'center', 'bottom']</code>  <code>module-attribute</code>","text":"<p>The vertical alignment of the elements.</p>"},{"location":"modules/#routelit.builder.RouteLitBuilder","title":"<code>RouteLitBuilder</code>","text":"Source code in <code>src/routelit/builder.py</code> <pre><code>class RouteLitBuilder:\n    static_assets_targets: ClassVar[List[AssetTarget]] = []\n\n    def __init__(\n        self,\n        request: RouteLitRequest,\n        session_state: PropertyDict,\n        fragments: MutableMapping[str, List[int]],\n        prev_root_element: Optional[RouteLitElement] = None,\n        cancel_event: Optional[asyncio.Event] = None,\n        should_rerun_event: Optional[asyncio.Event] = None,\n        initial_fragment_id: Optional[str] = None,\n        initial_target: Optional[BuilderTarget] = None,\n        event_queue: Optional[asyncio.Queue] = None,\n        loop: Optional[asyncio.AbstractEventLoop] = None,\n        parent_element: Optional[RouteLitElement] = None,\n        parent_builder: Optional[\"RouteLitBuilder\"] = None,\n        last_fragment_address: Optional[List[int]] = None,\n    ):\n        self.request = request\n        self.initial_fragment_id = initial_fragment_id\n        self.last_fragment_address = last_fragment_address\n        self.initial_target = (\n            initial_target if initial_target is not None else \"app\" if initial_fragment_id is None else \"fragment\"\n        )\n        self.fragments = fragments\n        self.prev_root_element = prev_root_element\n        self.has_prev_diff = False\n        self._event_queue = event_queue\n        self._loop = loop\n        self.cancel_event = cancel_event\n        self.head: Optional[Head] = None\n        self._parent_element = parent_element or RouteLitElement.create_root_element()\n        self._root_element = self._parent_element\n        self.session_state = session_state\n        self.parent_builder = parent_builder\n        self.active_child_builder: Optional[RouteLitBuilder] = None\n        self._prev_active_child_builder: Optional[RouteLitBuilder] = None\n        self.q_by_name: Dict[str, int] = {}\n        self.should_rerun_event = should_rerun_event\n        if self._root_element.name == RouteLitElement.ROOT_ELEMENT_NAME and initial_fragment_id is None:\n            self._on_init()\n\n    def _on_init(self) -&gt; None:\n        pass\n\n    def get_request(self) -&gt; RouteLitRequest:\n        return self.request\n\n    def _get_prefix(self) -&gt; str:\n        return self.active_child_builder._get_prefix() if self.active_child_builder else self._parent_element.key\n\n    def _schedule_event(self, event_data: Action) -&gt; bool:\n        \"\"\"\n        Schedule an event to be put in the queue from sync context\n        Returns True if the event was scheduled, False otherwise.\n        \"\"\"\n\n        if not (self._event_queue and self._loop):\n            # Nothing to do - no queue/loop configured.\n            return False\n\n        # Guard against scheduling onto a closed loop (can happen during\n        # teardown).\n        if self._loop.is_closed():\n            return False\n\n        self._loop.call_soon_threadsafe(self._event_queue.put_nowait, event_data)\n        return True\n\n    @property\n    def elements(self) -&gt; List[RouteLitElement]:\n        return self._root_element.get_children()\n\n    @property\n    def root_element(self) -&gt; RouteLitElement:\n        if self.initial_fragment_id and self._root_element.children:\n            return self._root_element.children[0]\n        return self._root_element\n\n    @property\n    def elements_count(self) -&gt; int:\n        return len(self.elements)\n\n    @property\n    def address(self) -&gt; List[int]:\n        return self._root_element.address or []\n\n    def _get_next_address(self) -&gt; List[int]:\n        if self.active_child_builder:\n            return self.active_child_builder._get_next_address()\n        else:\n            return [*self.address, self.elements_count]\n\n    def _get_last_address(self) -&gt; List[int]:\n        if self.active_child_builder:\n            return self.active_child_builder._get_last_address()\n        else:\n            return [*self.address, self.elements_count - 1]\n\n    def _build_nested_builder(self, element: RouteLitElement) -&gt; \"RouteLitBuilder\":\n        if element.address is None:\n            element.address = self._get_last_address()\n        prev_root_element = (\n            self.prev_root_element\n            if self.prev_root_element and self.prev_root_element.key == element.key\n            else get_element_at_address(self.prev_root_element, element.address)\n            if self.prev_root_element\n            else None\n        )\n        last_fragment_address = element.address if element.name == \"fragment\" else self.last_fragment_address\n        builder = self.__class__(\n            self.request,\n            fragments=self.fragments,\n            event_queue=self._event_queue,\n            loop=self._loop,\n            cancel_event=self.cancel_event,\n            session_state=self.session_state,\n            parent_element=element,\n            parent_builder=self,\n            initial_target=self.initial_target,\n            prev_root_element=prev_root_element,\n            should_rerun_event=self.should_rerun_event,\n            last_fragment_address=last_fragment_address,\n        )\n        return builder\n\n    def _get_parent_form_id(self) -&gt; Optional[str]:\n        if self._parent_element and self._parent_element.name == \"form\":\n            return self._parent_element.key\n        if self.active_child_builder:\n            return self.active_child_builder._get_parent_form_id()\n        if self._prev_active_child_builder:\n            return self._prev_active_child_builder._get_parent_form_id()\n        return None\n\n    def _new_text_id(self, name: str) -&gt; str:\n        prefix = self._get_prefix()\n        q_by_name = self.active_child_builder.q_by_name if self.active_child_builder else self.q_by_name\n        if name in q_by_name:\n            q_by_name[name] += 1\n        else:\n            q_by_name[name] = 1\n        key = f\"{prefix}_{name}_{q_by_name[name]}\"\n        return key\n\n    def _new_widget_id(self, name: str, label: str) -&gt; str:\n        hashed = hashlib.sha256(label.encode()).hexdigest()[:8]\n        prefix = self._get_prefix()\n        return f\"{prefix}_{name}_{hashed}\"\n\n    def _maybe_get_event(self, component_id: str) -&gt; Optional[RouteLitEvent]:\n        event = self.request.ui_event\n        if (\n            event\n            and event.get(\"type\") == \"submit\"\n            and (event_form_id := event.get(\"formId\"))\n            and self.session_state.get(\"__ignore_submit\") != event_form_id\n            and (form_id := self._get_parent_form_id())\n            and event_form_id == form_id\n        ):\n            events = self.session_state.get(f\"__events4later_{form_id}\", {})\n            self.session_state.pop(f\"__events4later_{form_id}\", None)\n            self.session_state[f\"__events_{form_id}\"] = events\n            self.session_state[\"__ignore_submit\"] = form_id\n            self.rerun(scope=\"app\", clear_event=False)\n\n        if event and event.get(\"componentId\") == component_id:\n            return event\n        if (\n            (form_id := self._get_parent_form_id())\n            and (events := self.session_state.get(f\"__events_{form_id}\", {}))\n            and component_id in events\n        ):\n            _event: RouteLitEvent = events[component_id]\n            events.pop(component_id, None)\n            self.session_state[f\"__events_{form_id}\"] = events\n            return _event\n        return None\n\n    def _get_event_value(self, component_id: str, event_type: str, attribute: Optional[str] = None) -&gt; Tuple[bool, Any]:\n        \"\"\"\n        Check if the last event is of the given type and component_id.\n        If attribute is not None, check if the event has the given attribute.\n        Returns a tuple of (has_event, event_data).\n        \"\"\"\n        event = self._maybe_get_event(component_id)\n        if event is not None and event.get(\"type\") == event_type:\n            if attribute is None:\n                return True, event[\"data\"]\n            else:\n                return True, event[\"data\"].get(attribute)\n        return False, None\n\n    def _append_element(self, element: RouteLitElement) -&gt; None:\n        \"\"\"\n        Append an element to the current builder.\n        Returns the index of the element in the builder.\n        Do not use this method directly, use the other methods instead, unless you are creating a custom element.\n        \"\"\"\n        if self.active_child_builder:\n            self.active_child_builder._append_element(element)\n            return\n\n        # do not append elements if the builder should rerun (when streaming)\n        if self.should_rerun_event and self.should_rerun_event.is_set():\n            return\n\n        if self.cancel_event and self.cancel_event.is_set():\n            raise StopException(\"Builder cancelled\")\n\n        element.props = remove_none_values(element.props)\n        self._parent_element.append_child(element)\n\n        if element.name == \"fragment\" and element.key != self.initial_fragment_id and element.address is not None:\n            self.fragments[element.key] = element.address\n\n        # skip sending action for fragment as root\n        if self.initial_target == \"fragment\" and element.name == \"fragment\" and self.initial_fragment_id is not None:\n            return\n\n        # skip the first address for fragment as root\n        address = self._get_last_address()[1:] if self.initial_target == \"fragment\" else self._get_last_address()\n\n        # check if the element is the same as the previous one\n        if (\n            self.prev_root_element is not None\n            and self.prev_root_element.children is not None\n            and len(address) &gt; 0\n            and address[-1] &lt; len(self.prev_root_element.children)\n            and (prev_element := self.prev_root_element.children[address[-1]])\n            and prev_element.key == element.key\n            and prev_element.props == element.props\n        ):\n            self._schedule_event(NoChangeAction(address=address, target=self.initial_target))\n            return\n\n        new_element = element.to_dict()\n        if element.name == \"fragment\" and self.last_fragment_address is not None and element.address is not None:\n            new_element[\"address\"] = element.address[len(self.last_fragment_address) - 1 :]\n\n        self._schedule_event(\n            SetAction(\n                element=new_element,\n                key=element.key,\n                address=address,\n                target=self.initial_target,\n            )\n        )\n\n    def _add_non_widget(self, element: RouteLitElement) -&gt; RouteLitElement:\n        self._append_element(element)\n        return element\n\n    def _add_widget(self, element: RouteLitElement) -&gt; None:\n        self._append_element(element)\n\n    def create_element(\n        self,\n        name: str,\n        key: Optional[str] = None,\n        props: Optional[Dict[str, Any]] = None,\n        children: Optional[List[RouteLitElement]] = None,\n        address: Optional[List[int]] = None,\n        virtual: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; RouteLitElement:\n        return RouteLitElement(\n            key=key or hashlib.sha256(name.encode()).hexdigest()[:8],\n            name=name,\n            props={**(props or {}), **kwargs},\n            children=children,\n            address=address,\n            virtual=virtual,\n        )\n\n    def _create_element(\n        self,\n        name: str,\n        key: str,\n        props: Optional[Dict[str, Any]] = None,\n        children: Optional[List[RouteLitElement]] = None,\n        address: Optional[List[int]] = None,\n        virtual: Optional[bool] = None,\n    ) -&gt; RouteLitElement:\n        element = RouteLitElement(\n            key=key,\n            name=name,\n            props=props or {},\n            children=children,\n            address=address,\n            virtual=virtual,\n        )\n        self._add_widget(element)\n        return element\n\n    def _fragment(self, key: Optional[str] = None) -&gt; \"RouteLitBuilder\":\n        key = key or self._new_text_id(\"fragment\")\n        fragment = self._create_element(\n            name=\"fragment\",\n            key=key,\n            props={\"id\": key},\n            address=self._get_next_address(),\n            virtual=True,\n        )\n        return self._build_nested_builder(fragment)\n\n    def _x_file_input(\n        self,\n        element_type: str,\n        key: str,\n        *,\n        multiple_attr: str = \"multiple\",\n        multiple: Optional[bool] = False,\n        **kwargs: Any,\n    ) -&gt; Union[IOBase, List[IOBase], None]:\n        value = self.session_state.get(key)\n        has_changed, maybe_files = self._get_event_value(key, \"change\", \"files\")\n        if has_changed:\n            if multiple is not True and isinstance(maybe_files, list):\n                # Single file mode (multiple=False or multiple=None/default)\n                value = maybe_files[0] if len(maybe_files) &gt; 0 else None\n            else:\n                value = maybe_files\n            self.session_state[key] = value\n        # ensure the value is seeked to the beginning\n        if value is not None and isinstance(value, IOBase):\n            value.seek(0)\n        if value is not None and isinstance(value, list):\n            for file in value:\n                file.seek(0)\n        self._create_element(\n            name=element_type,\n            key=key,\n            props={\"id\": key, multiple_attr: multiple, **kwargs},\n        )\n        return cast(Union[IOBase, List[IOBase]], value)\n\n    @overload\n    def file_input(\n        self, label: str, *, key: Optional[str] = None, accept_multiple_files: Literal[True], **kwargs: Any\n    ) -&gt; Optional[List[IOBase]]: ...\n\n    @overload\n    def file_input(\n        self, label: str, *, key: Optional[str] = None, accept_multiple_files: Literal[False], **kwargs: Any\n    ) -&gt; Optional[IOBase]: ...\n\n    @overload\n    def file_input(\n        self, label: str, *, key: Optional[str] = None, accept_multiple_files: None = None, **kwargs: Any\n    ) -&gt; Optional[IOBase]: ...\n\n    def file_input(\n        self,\n        label: str,\n        *,\n        key: Optional[str] = None,\n        accept_multiple_files: Optional[bool] = None,\n        accept: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Union[IOBase, List[IOBase], None]:\n        \"\"\"\n        Creates a file input component.\n        You'll get the bytes of the uploaded file (BytesIO object).\n        Useful for handling files in memory. Not suitable for large files.\n\n        Args:\n            label (str): The label of the file input.\n            key (Optional[str]): The key of the file input.\n            accept_multiple_files (Optional[bool]): Whether to accept multiple files.\n            accept (Optional[str]): The accept attribute of the file input.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the file input.\n\n        Returns:\n            Optional[IOBase|List[IOBase]]: The file input component.\n\n        Example:\n        ```python\n        # Multiple files\n        files = ui.file_input(\"Files\", accept_multiple_files=True, accept=\"text/plain, .txt\")\n        if files:\n            for file in files:\n                ui.text(file.read().decode(\"utf-8\"))\n\n        # Single file\n        single_file = ui.file_input(\"Single File\", accept_multiple_files=False, accept=\"text/plain, .txt\")\n        if single_file:\n            ui.text(single_file.read().decode(\"utf-8\"))\n\n        # Handling images\n        import base64\n        image = ui.file_input(\"Image\", accept=\"image/png\")\n        if image:\n            ui.image(src=f\"data:image/png;base64,{base64.b64encode(image.read()).decode('utf-8')}\", width=128)\n        if image and ui.button(\"Save image\"):\n            with open(\"image.png\", \"wb\") as f:\n                f.write(image.read())\n                ui.text(\"Image saved\")\n        ```\n        \"\"\"\n        return self._x_file_input(\n            \"input-file\",\n            key or self._new_widget_id(\"input-file\", label),\n            multiple=accept_multiple_files,\n            label=label,\n            accept=accept,\n            **kwargs,\n        )\n\n    def _x_dialog(\n        self,\n        element_type: str,\n        key: str,\n        *,\n        on_close: Optional[Callable[[], Optional[bool]]] = None,\n        **kwargs: Any,\n    ) -&gt; \"RouteLitBuilder\":\n        is_closed, _ = self._get_event_value(key, \"close\")\n        if is_closed:\n            should_rerun = True\n            if on_close and (result := on_close()) is not None:\n                should_rerun = result\n            if should_rerun:\n                self.rerun(scope=\"app\")\n        dialog = self._create_element(\n            name=element_type,\n            key=key,\n            props={\"id\": key, **kwargs},\n            virtual=True,\n        )\n        return self._build_nested_builder(dialog)\n\n    def _create_builder_element(\n        self,\n        name: str,\n        key: str,\n        props: Optional[Dict[str, Any]] = None,\n        address: Optional[List[int]] = None,\n        virtual: Optional[bool] = None,\n    ) -&gt; \"RouteLitBuilder\":\n        element = self._create_element(\n            name=name,\n            key=key,\n            props=props or {},\n            address=address,\n            virtual=virtual,\n        )\n        return self._build_nested_builder(element)\n\n    def _dialog(self, key: Optional[str] = None, **kwargs: Any) -&gt; \"RouteLitBuilder\":\n        return self._x_dialog(\n            \"dialog\",\n            key or self._new_text_id(\"dialog\"),\n            open=True,\n            closable=True,\n            **kwargs,\n        )\n\n    def form(self, key: str) -&gt; \"RouteLitBuilder\":\n        \"\"\"\n        Creates a form area that do not submit input values to the server until the form is submitted.\n        Use button(..., event_name=\"submit\") to submit the form.\n\n        Args:\n            key (str): The key of the form.\n\n        Returns:\n            RouteLitBuilder: A builder for the form.\n\n        Example:\n        ```python\n        with ui.form(\"login\"):\n            username = ui.text_input(\"Username\")\n            password = ui.text_input(\"Password\", type=\"password\")\n            is_submitted = ui.button(\"Login\", event_name=\"submit\")\n            if is_submitted:\n                ui.text(f\"Login successful for {username}\")\n        ```\n        \"\"\"\n        form = self._create_element(\n            name=\"form\",\n            key=key,\n            props={\"id\": key},\n            virtual=True,\n        )\n        return self._build_nested_builder(form)\n\n    def link(\n        self,\n        href: str,\n        text: str = \"\",\n        *,\n        replace: bool = False,\n        is_external: bool = False,\n        key: Optional[str] = None,\n        rl_element_type: str = \"link\",\n        rl_text_attr: str = \"text\",\n        rl_virtual: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; RouteLitElement:\n        \"\"\"\n        Creates a link component. Use this to navigate to a different page.\n\n        Args:\n            href (str): The href of the link.\n            text (str): The text of the link.\n            replace (bool): Whether to replace the current page from the history.\n            is_external (bool): Whether the link is external to the current app.\n            key (Optional[str]): The key of the link.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the link.\n\n        Example:\n        ```python\n        ui.link(\"/signup\", text=\"Signup\")\n        ui.link(\"/login\", text=\"Login\", replace=True)\n        ui.link(\"https://www.google.com\", text=\"Google\", is_external=True)\n        ```\n        \"\"\"\n        new_element = self._create_element(\n            name=rl_element_type,\n            key=key or self._new_text_id(rl_element_type),\n            props={\n                \"href\": href,\n                \"replace\": replace,\n                \"isExternal\": is_external,\n                rl_text_attr: text,\n                **kwargs,\n            },\n            virtual=rl_virtual,\n        )\n        return new_element\n\n    def link_area(\n        self,\n        href: str,\n        replace: bool = False,\n        is_external: bool = False,\n        key: Optional[str] = None,\n        className: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; \"RouteLitBuilder\":\n        \"\"\"\n        Creates a link area component. Use this element which is a container of other elements.\n\n        Args:\n            href (str): The href of the link.\n            replace (bool): Whether to replace the current page.\n            is_external (bool): Whether the link is external.\n            key (Optional[str]): The key of the link area.\n            className (Optional[str]): The class name of the link area.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the link area.\n\n        Example:\n        ```python\n        with ui.link_area(\"https://www.google.com\"):\n            with ui.flex(direction=\"row\", gap=\"small\"):\n                ui.image(\"https://www.google.com/favicon.ico\", width=\"24px\", height=\"24px\")\n                ui.text(\"Google\")\n        ```\n        \"\"\"\n        link_element = self.link(\n            href,\n            replace=replace,\n            is_external=is_external,\n            key=key,\n            className=f\"rl-no-link-decoration {className or ''}\",\n            **kwargs,\n        )\n        return self._build_nested_builder(link_element)\n\n    def container(self, key: Optional[str] = None, height: Optional[str] = None, **kwargs: Any) -&gt; \"RouteLitBuilder\":\n        \"\"\"\n        Creates a container component.\n\n        Args:\n            key (Optional[str]): The key of the container.\n            height (Optional[str]): The height of the container.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the container.\n\n        Example:\n        ```python\n        with ui.container(height=\"100px\"):\n            ui.text(\"Container\")\n        ```\n        \"\"\"\n        container = self._create_element(\n            name=\"container\",\n            key=key or self._new_text_id(\"container\"),\n            props={\"style\": {\"height\": height}, **kwargs},\n        )\n        return self._build_nested_builder(container)\n\n    def markdown(\n        self,\n        body: str,\n        *,\n        allow_unsafe_html: bool = False,\n        key: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Creates a markdown component.\n\n        Args:\n            body (str): The body of the markdown.\n            allow_unsafe_html (bool): Whether to allow unsafe HTML.\n            key (Optional[str]): The key of the markdown.\n\n        Example:\n        ```python\n        ui.markdown(\"**Bold** *italic* [link](https://www.google.com)\")\n        ```\n        \"\"\"\n        self._create_element(\n            name=\"markdown\",\n            key=key or self._new_text_id(\"markdown\"),\n            props={\"body\": body, \"allowUnsafeHtml\": allow_unsafe_html, **kwargs},\n        )\n\n    def text(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Creates a text component.\n\n        Args:\n            body (str): The body of the text.\n            key (Optional[str]): The key of the text.\n\n        Example:\n        ```python\n        ui.text(\"Text\")\n        ```\n        \"\"\"\n        self.markdown(body, allow_unsafe_html=False, key=key, **kwargs)\n\n    def title(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Creates a title component.\n\n        Args:\n            body (str): The body of the title.\n            key (Optional[str]): The key of the title.\n\n        Example:\n        ```python\n        ui.title(\"Title\")\n        ```\n        \"\"\"\n        self._create_element(\n            name=\"title\",\n            key=key or self._new_text_id(\"title\"),\n            props={\"children\": body, **kwargs},\n        )\n\n    def header(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Creates a header component.\n\n        Args:\n            body (str): The body of the header.\n            key (Optional[str]): The key of the header.\n\n        Example:\n        ```python\n        ui.header(\"Header\")\n        ```\n        \"\"\"\n        self._create_element(\n            name=\"header\",\n            key=key or self._new_text_id(\"header\"),\n            props={\"children\": body, **kwargs},\n        )\n\n    def subheader(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Creates a subheader component.\n\n        Args:\n            body (str): The body of the subheader.\n            key (Optional[str]): The key of the subheader.\n\n        Example:\n        ```python\n        ui.subheader(\"Subheader\")\n        ```\n        \"\"\"\n        self._create_element(\n            name=\"subheader\",\n            key=key or self._new_text_id(\"subheader\"),\n            props={\"children\": body, **kwargs},\n        )\n\n    def image(self, src: str, *, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Creates an image component.\n\n        Args:\n            src (str): The source of the image.\n            key (Optional[str]): The key of the image.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the image.\n\n        Example:\n        ```python\n        ui.image(\"https://www.google.com/favicon.ico\", alt=\"Google\", width=\"24px\", height=\"24px\")\n        ```\n        \"\"\"\n        self._create_element(\n            name=\"image\",\n            key=key or self._new_text_id(\"image\"),\n            props={\"src\": src, **kwargs},\n        )\n\n    def expander(self, title: str, *, is_open: Optional[bool] = None, key: Optional[str] = None) -&gt; \"RouteLitBuilder\":\n        \"\"\"\n        Creates an expander component that can be used as both a context manager and a regular function call.\n\n        Args:\n            title (str): The title of the expander.\n            is_open (Optional[bool]): Whether the expander is open.\n            key (Optional[str]): The key of the expander.\n\n        Returns:\n            RouteLitBuilder: A builder for the expander.\n        ```python\n        Usage:\n            def build_index_view(ui: RouteLitBuilder):\n                # Context manager style\n                with ui.expander(\"Title\"):\n                    ui.text(\"Content\")\n\n                with ui.expander(\"Title\", is_open=True) as exp0:\n                    exp0.text(\"Content\")\n\n                # Function call style\n                exp = ui.expander(\"Title\")\n                exp.text(\"Content\")\n        ```\n        \"\"\"\n        new_key = key or self._new_widget_id(\"expander\", title)\n        new_element = self._create_element(\n            name=\"expander\",\n            key=new_key,\n            props={\"title\": title, \"open\": is_open},\n        )\n        return self._build_nested_builder(new_element)\n\n    def columns(\n        self,\n        spec: Union[int, List[int]],\n        *,\n        key: Optional[str] = None,\n        vertical_alignment: VerticalAlignment = \"top\",\n        columns_gap: ColumnsGap = \"small\",\n    ) -&gt; List[\"RouteLitBuilder\"]:\n        \"\"\"Creates a flexbox layout with several columns with the given spec.\n\n        Args:\n            spec (int | List[int]): The specification of the columns. Can be an integer or a list of integers.\n            key (Optional[str]): The key of the container.\n            vertical_alignment (VerticalAlignment): The vertical alignment of the columns: \"top\", \"center\", \"bottom\".\n            columns_gap (ColumnsGap): The gap between the columns: \"none\", \"small\", \"medium\", \"large\".\n\n        Returns:\n            List[RouteLitBuilder]: A list of builders for the columns.\n\n        Examples:\n        ```python\n            # 2 columns with equal width\n            col1, col2 = ui.columns(2)\n            # usage inline\n            col1.text(\"Column 1\")\n            col2.text(\"Column 2\")\n            # usage as context manager\n            with col1:\n                ui.text(\"Column 1\")\n            with col2:\n                ui.text(\"Column 2\")\n            # usage with different widths\n            col1, col2, col3 = ui.columns([2, 1, 1])\n            col1.text(\"Column 1\")\n            col2.text(\"Column 2\")\n            col3.text(\"Column 3\")\n        ```\n        \"\"\"\n        if isinstance(spec, int):\n            spec = [1] * spec\n        container_key = key or self._new_text_id(\"container\")\n        container = self._create_element(\n            name=\"container\",\n            key=container_key,\n            props={\n                \"className\": \"rl-flex rl-flex-row\",\n                \"style\": {\n                    \"alignItems\": verticalAlignmentMap.get(vertical_alignment, \"top\"),\n                    \"columnGap\": columnsGapMap.get(columns_gap, \"small\"),\n                },\n            },\n        )\n        container_builder = self._build_nested_builder(container)\n        with container_builder:\n            element_builders = []\n            for column_spec in spec:\n                column = self._create_element(\n                    name=\"container\",\n                    key=self._new_text_id(\"col\"),\n                    props={\"style\": {\"flex\": column_spec}},\n                )\n                element_builders.append(self._build_nested_builder(column))\n        return element_builders\n\n    def flex(\n        self,\n        direction: Literal[\"row\", \"col\"] = \"col\",\n        wrap: Literal[\"wrap\", \"nowrap\"] = \"nowrap\",\n        justify_content: Literal[\"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\"] = \"start\",\n        align_items: Literal[\"normal\", \"start\", \"end\", \"center\", \"baseline\", \"stretch\"] = \"normal\",\n        align_content: Literal[\"normal\", \"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\"] = \"normal\",\n        gap: Optional[str] = None,\n        key: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; \"RouteLitBuilder\":\n        \"\"\"\n        Creates a flex container with the given direction, wrap, justify content, align items, align content, gap, and key.\n        \"\"\"\n        container = self._create_element(\n            name=\"flex\",\n            key=key or self._new_text_id(\"flex\"),\n            props={\n                \"direction\": direction,\n                \"flexWrap\": wrap,\n                \"justifyContent\": justify_content,\n                \"alignItems\": align_items,\n                \"alignContent\": align_content,\n                \"gap\": gap,\n                **kwargs,\n            },\n        )\n        return self._build_nested_builder(container)\n\n    def _x_button(\n        self,\n        element_type: str,\n        text: str,\n        *,\n        event_name: Literal[\"click\", \"submit\"] = \"click\",\n        key: Optional[str] = None,\n        on_click: Optional[Callable[[], None]] = None,\n        rl_virtual: Optional[bool] = None,\n        **kwargs: Any,\n    ) -&gt; bool:\n        button = self._create_element(\n            name=element_type,\n            key=key or self._new_widget_id(element_type, text),\n            props={\n                \"children\": text,\n                \"rlEventName\": event_name,\n                **kwargs,\n            },\n            virtual=rl_virtual,\n        )\n        is_clicked, _ = self._get_event_value(button.key, event_name)\n        if is_clicked and on_click:\n            on_click()\n        return is_clicked\n\n    def button(\n        self,\n        text: str,\n        *,\n        key: Optional[str] = None,\n        on_click: Optional[Callable[[], None]] = None,\n        **kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"\n        Creates a button with the given text, key, on click, and keyword arguments.\n\n        Args:\n            text (str): The text of the button.\n            key (Optional[str]): The key of the button.\n            on_click (Optional[Callable[[], None]]): The function to call when the button is clicked.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the button.\n\n        Returns:\n            bool: Whether the button was clicked.\n\n        Example:\n        ```python\n        is_clicked = ui.button(\"Click me\", on_click=lambda: print(\"Button clicked\"))\n        if is_clicked:\n            ui.text(\"Button clicked\")\n        ```\n        \"\"\"\n        return self._x_button(\"button\", text, event_name=\"click\", key=key, on_click=on_click, **kwargs)\n\n    def form_submit_button(\n        self,\n        text: str,\n        *,\n        key: Optional[str] = None,\n        on_click: Optional[Callable[[], None]] = None,\n        **kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"\n        Creates a form submit button with the given text, key, on click, and keyword arguments.\n\n        Args:\n            text (str): The text of the button.\n            key (Optional[str]): The key of the button.\n            on_click (Optional[Callable[[], None]]): The function to call when the button is clicked.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the button.\n\n        Returns:\n            bool: Whether the button was clicked.\n\n        Example:\n        ```python\n        with ui.form(key=\"form_key\"):\n            is_submitted = ui.form_submit_button(\"Submit\", on_click=lambda: print(\"Form submitted\"))\n            if is_submitted:\n                ui.text(\"Form submitted\")\n        ```\n        \"\"\"\n        return self._x_button(\"button\", text, event_name=\"submit\", key=key, on_click=on_click, **kwargs)\n\n    def _x_input(\n        self,\n        element_type: str,\n        key: str,\n        *,\n        value: Optional[Any] = None,\n        on_change: Optional[Callable[[Any], None]] = None,\n        event_name: str = \"change\",\n        event_value_attr: str = \"value\",\n        value_attr: str = \"defaultValue\",\n        rl_format_func: Optional[Callable[[Any], Any]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[str, Any]]:\n        new_value: Any = self.session_state.get(key, value)\n        has_changed, event_value = self._get_event_value(key, event_name, event_value_attr)\n        if has_changed:\n            new_value = event_value\n            if rl_format_func:\n                new_value = rl_format_func(new_value)\n            self.session_state[key] = new_value\n            if on_change:\n                on_change(new_value)\n        self._create_element(\n            name=element_type,\n            key=key,\n            props={\n                value_attr: new_value,\n                **kwargs,\n            },\n        )\n        return new_value\n\n    def _x_radio_select(\n        self,\n        element_type: str,\n        key: str,\n        *,\n        options: List[Union[RLOption, str, Dict[str, Any]]],\n        value: Optional[Any] = None,\n        on_change: Optional[Callable[[Any], None]] = None,\n        format_func: Optional[Callable[[Any], str]] = None,\n        options_attr: str = \"options\",\n        **kwargs: Any,\n    ) -&gt; Any:\n        new_value = self.session_state.get(key, value)\n        has_changed, event_value = self._get_event_value(key, \"change\", \"value\")\n        if has_changed:\n            new_value = event_value\n            self.session_state[key] = new_value\n            if on_change:\n                on_change(new_value)\n        new_options = format_options(options, format_func)\n        self._create_element(\n            name=element_type,\n            key=key,\n            props={\n                \"value\": new_value,\n                options_attr: new_options,\n                **kwargs,\n            },\n        )\n        return new_value\n\n    def text_input(\n        self,\n        label: str,\n        *,\n        type: TextInputType = \"text\",\n        value: Optional[str] = None,\n        key: Optional[str] = None,\n        on_change: Optional[Callable[[str], None]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Creates a text input with the given label and value.\n\n        Args:\n            label (str): The label of the text input.\n            type (TextInputType): The type of the text input.\n            value (Optional[str]): The value of the text input.\n            key (Optional[str]): The key of the text input.\n            on_change (Optional[Callable[[str], None]]): The function to call when the value changes. The function will be called with the new value.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the text input.\n\n        Returns:\n            str: The text value of the text input.\n\n        Example:\n        ```python\n        name = ui.text_input(\"Name\", value=\"John\", on_change=lambda value: print(f\"Name changed to {value}\"))\n        ui.text(f\"Name is {name}\")\n        ```\n        \"\"\"\n        return self._x_input(\n            \"single-text-input\",\n            key or self._new_widget_id(\"text-input\", label),\n            value=value,\n            on_change=on_change,\n            type=type,\n            label=label,\n            **kwargs,\n        )\n\n    def hr(self, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Creates a horizontal rule.\n        \"\"\"\n        self._create_element(name=\"hr\", key=key or self._new_text_id(\"hr\"), props=kwargs)\n\n    def textarea(\n        self,\n        label: str,\n        *,\n        value: Optional[str] = None,\n        key: Optional[str] = None,\n        on_change: Optional[Callable[[str], None]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Creates a textarea with the given label and value.\n\n        Args:\n            label (str): The label of the textarea.\n            value (Optional[str]): The value of the textarea.\n            key (Optional[str]): The key of the textarea.\n            on_change (Optional[Callable[[str], None]]): The function to call when the value changes. The function will be called with the new value.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the textarea.\n\n        Returns:\n            str: The text value of the textarea.\n\n        Example:\n        ```python\n        text = ui.textarea(\"Text\", value=\"Hello, world!\", on_change=lambda value: print(f\"Text changed to {value}\"))\n        ui.text(f\"Text is {text}\")\n        ```\n        \"\"\"\n        return self._x_input(\n            \"single-textarea\",\n            key or self._new_widget_id(\"textarea\", label),\n            value=value,\n            on_change=on_change,\n            label=label,\n            **kwargs,\n        )\n\n    def radio(\n        self,\n        label: str,\n        options: List[Union[RLOption, str, Dict[str, Any]]],\n        *,\n        value: Optional[Any] = None,\n        key: Optional[str] = None,\n        on_change: Optional[Callable[[Any], None]] = None,\n        flex_direction: Literal[\"row\", \"col\"] = \"col\",\n        format_func: Optional[Callable[[Any], str]] = None,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Creates a radio group with the given label and options.\n\n        Args:\n            label (str): The label of the radio group.\n            options (List[RLOption | str | Dict[str, Any]]): The options of the radio group. Each option can be a string or a dictionary with the following keys:\n                - label: The label of the option.\n                - value: The value of the option.\n                - caption: The caption of the option.\n                - disabled: Whether the option is disabled.\n            value (str | int | None): The value of the radio group.\n            key (str | None): The key of the radio group.\n            on_change (Callable[[str | int | None], None] | None): The function to call when the value changes. The function will be called with the new value.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the radio group.\n        Returns:\n            str | int | None: The value of the selected radio option.\n\n        Example:\n        ```python\n        value = ui.radio(\"Radio\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=\"Option 1\", on_change=lambda value: print(f\"Radio value changed to {value}\"))\n        ui.text(f\"Radio value is {value}\")\n        ```\n        \"\"\"\n        return self._x_radio_select(\n            \"radio\",\n            key or self._new_widget_id(\"radio\", label),\n            options=options,\n            value=value,\n            on_change=on_change,\n            label=label,\n            format_func=format_func,\n            flexDirection=flex_direction,\n            **kwargs,\n        )\n\n    def select(\n        self,\n        label: str,\n        options: List[Union[RLOption, str, Dict[str, Any]]],\n        *,\n        value: Any = \"\",\n        key: Optional[str] = None,\n        on_change: Optional[Callable[[Any], None]] = None,\n        format_func: Optional[Callable[[Any], str]] = None,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"\n        Creates a select dropdown with the given label and options.\n\n        Args:\n            label (str): The label of the select dropdown.\n            options (List[RLOption | str | Dict[str, Any]]): The options of the select dropdown. Each option can be a string or a dictionary with the following keys: (label, value, disabled)\n                - label: The label of the option.\n                - value: The value of the option.\n                - disabled: Whether the option is disabled.\n            value (str | int): The value of the select dropdown.\n            key (str | None): The key of the select dropdown.\n            on_change (Callable[[str | int | None], None] | None): The function to call when the value changes. The function will be called with the new value.\n            format_func (Callable[[Any], str] | None): The function to format the options.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the select dropdown.\n\n        Returns:\n            Any: The value of the select dropdown.\n\n        Example:\n        ```python\n        value = ui.select(\"Select\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=\"Option 1\", on_change=lambda value: print(f\"Select value changed to {value}\"))\n        ui.text(f\"Select value is {value}\")\n        ```\n        \"\"\"\n        return self._x_radio_select(\n            \"select\",\n            key or self._new_widget_id(\"select\", label),\n            options=options,\n            value=value,\n            on_change=on_change,\n            format_func=format_func,\n            label=label,\n            **kwargs,\n        )\n\n    def _x_checkbox(\n        self,\n        element_type: str,\n        key: str,\n        *,\n        checked: bool = False,\n        on_change: Optional[Callable[[bool], None]] = None,\n        checked_attr: str = \"checked\",\n        **kwargs: Any,\n    ) -&gt; bool:\n        value_key = key\n        default_key = f\"__{key}_default\"\n\n        current_value = self.session_state.get(key)\n        previous_default = self.session_state.get(f\"__{key}_default\")\n\n        # Initialize or update if default changed\n        if current_value is None:\n            # First time - use the checked parameter\n            self.session_state[value_key] = checked\n            self.session_state[default_key] = checked\n            current_value = checked\n        elif previous_default != checked:\n            # Default value changed - update to new default\n            self.session_state[value_key] = checked\n            self.session_state[default_key] = checked\n            current_value = checked\n\n        # Handle user interaction events\n        has_changed, event_value = self._get_event_value(key, \"change\", \"checked\")\n        if has_changed:\n            new_value = bool(event_value) if event_value is not None else False\n            self.session_state[value_key] = new_value\n            if on_change:\n                on_change(new_value)\n            current_value = new_value\n\n        self._create_element(\n            name=element_type,\n            key=key,\n            props={\n                checked_attr: current_value,\n                **kwargs,\n            },\n        )\n        return bool(current_value)\n\n    def checkbox(\n        self,\n        label: str,\n        *,\n        checked: bool = False,\n        key: Optional[str] = None,\n        on_change: Optional[Callable[[bool], None]] = None,\n        **kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"\n        Creates a checkbox with the given label and value.\n\n        Args:\n            label (str): The label of the checkbox.\n            checked (bool): Whether the checkbox is checked.\n            key (str | None): The key of the checkbox.\n            on_change (Callable[[bool], None] | None): The function to call when the value changes.\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the checkbox.\n\n        Returns:\n            bool: Whether the checkbox is checked.\n\n        Example:\n        ```python\n        is_checked = ui.checkbox(\"Check me\", on_change=lambda checked: print(f\"Checkbox is {'checked' if checked else 'unchecked'}\"))\n        if is_checked:\n            ui.text(\"Checkbox is checked\")\n        ```\n        \"\"\"\n        return self._x_checkbox(\n            \"single-checkbox\",\n            key or self._new_widget_id(\"checkbox\", label),\n            checked=checked,\n            on_change=on_change,\n            label=label,\n            **kwargs,\n        )\n\n    def _x_checkbox_group(\n        self,\n        element_type: str,\n        key: str,\n        *,\n        options: List[Union[RLOption, str, Dict[str, Any]]],\n        format_func: Optional[Callable[[Any], str]] = None,\n        value: Optional[List[Any]] = None,\n        on_change: Optional[Callable[[List[Any]], None]] = None,\n        value_attr: str = \"value\",\n        options_attr: str = \"options\",\n        **kwargs: Any,\n    ) -&gt; List[Any]:\n        new_value: List[Any] = self.session_state.get(key, value) or []\n        if not isinstance(new_value, list):\n            new_value = value or []\n        has_changed, event_value = self._get_event_value(key, \"change\", \"value\")\n        if has_changed:\n            new_value = event_value if isinstance(event_value, list) else []\n            self.session_state[key] = new_value\n            if on_change:\n                on_change(new_value)\n        new_options = format_options(options, format_func)\n        self._create_element(\n            name=element_type,\n            key=key,\n            props={\n                value_attr: new_value,\n                options_attr: new_options,\n                **kwargs,\n            },\n        )\n        return new_value\n\n    def checkbox_group(\n        self,\n        label: str,\n        options: List[Union[RLOption, str, Dict[str, Any]]],\n        *,\n        value: Optional[List[Any]] = None,\n        key: Optional[str] = None,\n        on_change: Optional[Callable[[List[Any]], None]] = None,\n        format_func: Optional[Callable[[Any], str]] = None,\n        flex_direction: Literal[\"row\", \"col\"] = \"col\",\n        **kwargs: Any,\n    ) -&gt; List[Any]:\n        \"\"\"\n        Creates a checkbox group with the given label and options.\n\n        Args:\n            label (str): The label of the checkbox group.\n            options (List[RLOption | str | Dict[str, Any]]): The options of the checkbox group. Each option can be a string or a dictionary with the following keys: label, value, caption (optional), disabled (optional).\n            value (List[str | int] | None): The value of the checkbox group.\n            key (str | None): The key of the checkbox group.\n            on_change (Callable[[List[str | int]], None] | None): The function to call when the value changes.\n            format_func (Callable[[Any], str] | None): The function to format the options.\n            flex_direction (Literal[\"row\", \"col\"]): The direction of the checkbox group: \"row\", \"col\".\n            kwargs (Dict[str, Any]): The keyword arguments to pass to the checkbox group.\n        Returns:\n            List[str | int]: The value of the checkbox group.\n\n        Example:\n        ```python\n        selected_options = ui.checkbox_group(\"Checkbox Group\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=[\"Option 1\"], on_change=lambda value: print(f\"Checkbox group value changed to {value}\"))\n        ui.text(f\"Selected options: {', '.join(selected_options) if selected_options else 'None'}\")\n        ```\n        \"\"\"\n        return self._x_checkbox_group(\n            \"checkbox-group\",\n            key or self._new_widget_id(\"checkbox-group\", label),\n            label=label,\n            options=options,\n            value=value,\n            on_change=on_change,\n            format_func=format_func,\n            flexDirection=flex_direction,\n            **kwargs,\n        )\n\n    def rerun(self, scope: RerunType = \"auto\", clear_event: bool = True) -&gt; None:\n        \"\"\"\n        Reruns the current page. Use this to rerun the app or the fragment depending on the context.\n\n        Args:\n            scope (RerunType): The scope of the rerun. \"auto\" will rerun the app or the fragment depending on the context, \"app\" will rerun the entire app\n            clear_event (bool): Whether to clear the event.\n\n        Example:\n        ```python\n        counter = ui.session_state.get(\"counter\", 0)\n        ui.text(f\"Counter is {counter}\")\n        should_increase = ui.button(\"Increment\")\n        if should_increase:\n            ui.session_state[\"counter\"] = counter + 1\n            ui.rerun()\n        ```\n        \"\"\"\n        if self.should_rerun_event:\n            self.should_rerun_event.set()\n        if clear_event:\n            self.request.clear_event()\n        if scope == \"app\":\n            self.request.clear_fragment_id()\n        target = \"app\" if scope == \"app\" else self.initial_target\n        # when running in stream mode, we need to schedule the rerun action to the event queue\n        # so that the rerun action would be got with event queue loop can be cancelled\n        if self._schedule_event(RerunAction(address=[-1], target=target)):\n            return\n        raise RerunException(self.session_state.get_data(), scope=scope)\n\n    def get_head(self) -&gt; Head:\n        if self.head is None:\n            self.head = Head()\n        return self.head\n\n    def set_page_config(self, page_title: Optional[str] = None, page_description: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Sets the page title and description.\n\n        Args:\n            page_title (str | None): The title of the page.\n            page_description (str | None): The description of the page.\n        \"\"\"\n        self.head = Head(title=page_title, description=page_description)\n        self._create_element(\n            name=\"head\",\n            key=\"__head__\",\n            props={\n                \"title\": page_title,\n                \"description\": page_description,\n            },\n        )\n\n    def __enter__(self) -&gt; \"RouteLitBuilder\":\n        # When using with builder.element():\n        # Make parent builder redirect to this one\n        if self.parent_builder:\n            self._prev_active_child_builder = self.parent_builder.active_child_builder\n            self.parent_builder.active_child_builder = self\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n        # Reset parent's active child when exiting context\n        if self.parent_builder:\n            if self._prev_active_child_builder:\n                self.parent_builder.active_child_builder = self._prev_active_child_builder\n                self._prev_active_child_builder = None\n            else:\n                self.parent_builder.active_child_builder = None\n\n    def __call__(self, *args: Any, **kwds: Any) -&gt; \"RouteLitBuilder\":\n        return self\n\n    @property\n    def parent_element(self) -&gt; RouteLitElement:\n        return self._parent_element\n\n    def get_fragments(self) -&gt; MutableMapping[str, List[int]]:\n        return self.fragments\n\n    def handle_view_task_done(self) -&gt; None:\n        self._schedule_event(\n            ViewTaskDoneAction(\n                address=[-1],\n                target=self.initial_target,\n            )\n        )\n\n    def on_end(self) -&gt; None:\n        self.session_state.pop(\"__ignore_submit\", None)\n        if self.should_rerun_event and self.should_rerun_event.is_set():\n            return  # skip the last action when should_rerun is True\n        self._schedule_event(\n            LastAction(\n                address=None,\n                target=self.initial_target,\n            )\n        )\n\n    @classmethod\n    def get_client_resource_paths(cls) -&gt; List[AssetTarget]:\n        static_assets_targets = []\n        for c in cls.__mro__:\n            if hasattr(c, \"static_assets_targets\") and isinstance(c.static_assets_targets, list):\n                static_assets_targets.extend(c.static_assets_targets)\n        # Remove duplicates while preserving order (works with unhashable types like dictionaries)\n        seen = []\n        result = []\n        for item in static_assets_targets:\n            if item not in seen:\n                seen.append(item)\n                result.append(item)\n        return result\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.button","title":"<code>button(text, *, key=None, on_click=None, **kwargs)</code>","text":"<p>Creates a button with the given text, key, on click, and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text of the button.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the button.</p> <code>None</code> <code>on_click</code> <code>Optional[Callable[[], None]]</code> <p>The function to call when the button is clicked.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the button.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the button was clicked.</p> <p>Example:</p> <pre><code>is_clicked = ui.button(\"Click me\", on_click=lambda: print(\"Button clicked\"))\nif is_clicked:\n    ui.text(\"Button clicked\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def button(\n    self,\n    text: str,\n    *,\n    key: Optional[str] = None,\n    on_click: Optional[Callable[[], None]] = None,\n    **kwargs: Any,\n) -&gt; bool:\n    \"\"\"\n    Creates a button with the given text, key, on click, and keyword arguments.\n\n    Args:\n        text (str): The text of the button.\n        key (Optional[str]): The key of the button.\n        on_click (Optional[Callable[[], None]]): The function to call when the button is clicked.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the button.\n\n    Returns:\n        bool: Whether the button was clicked.\n\n    Example:\n    ```python\n    is_clicked = ui.button(\"Click me\", on_click=lambda: print(\"Button clicked\"))\n    if is_clicked:\n        ui.text(\"Button clicked\")\n    ```\n    \"\"\"\n    return self._x_button(\"button\", text, event_name=\"click\", key=key, on_click=on_click, **kwargs)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.checkbox","title":"<code>checkbox(label, *, checked=False, key=None, on_change=None, **kwargs)</code>","text":"<p>Creates a checkbox with the given label and value.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the checkbox.</p> required <code>checked</code> <code>bool</code> <p>Whether the checkbox is checked.</p> <code>False</code> <code>key</code> <code>str | None</code> <p>The key of the checkbox.</p> <code>None</code> <code>on_change</code> <code>Callable[[bool], None] | None</code> <p>The function to call when the value changes.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the checkbox.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the checkbox is checked.</p> <p>Example:</p> <pre><code>is_checked = ui.checkbox(\"Check me\", on_change=lambda checked: print(f\"Checkbox is {'checked' if checked else 'unchecked'}\"))\nif is_checked:\n    ui.text(\"Checkbox is checked\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def checkbox(\n    self,\n    label: str,\n    *,\n    checked: bool = False,\n    key: Optional[str] = None,\n    on_change: Optional[Callable[[bool], None]] = None,\n    **kwargs: Any,\n) -&gt; bool:\n    \"\"\"\n    Creates a checkbox with the given label and value.\n\n    Args:\n        label (str): The label of the checkbox.\n        checked (bool): Whether the checkbox is checked.\n        key (str | None): The key of the checkbox.\n        on_change (Callable[[bool], None] | None): The function to call when the value changes.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the checkbox.\n\n    Returns:\n        bool: Whether the checkbox is checked.\n\n    Example:\n    ```python\n    is_checked = ui.checkbox(\"Check me\", on_change=lambda checked: print(f\"Checkbox is {'checked' if checked else 'unchecked'}\"))\n    if is_checked:\n        ui.text(\"Checkbox is checked\")\n    ```\n    \"\"\"\n    return self._x_checkbox(\n        \"single-checkbox\",\n        key or self._new_widget_id(\"checkbox\", label),\n        checked=checked,\n        on_change=on_change,\n        label=label,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.checkbox_group","title":"<code>checkbox_group(label, options, *, value=None, key=None, on_change=None, format_func=None, flex_direction='col', **kwargs)</code>","text":"<p>Creates a checkbox group with the given label and options.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the checkbox group.</p> required <code>options</code> <code>List[RLOption | str | Dict[str, Any]]</code> <p>The options of the checkbox group. Each option can be a string or a dictionary with the following keys: label, value, caption (optional), disabled (optional).</p> required <code>value</code> <code>List[str | int] | None</code> <p>The value of the checkbox group.</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key of the checkbox group.</p> <code>None</code> <code>on_change</code> <code>Callable[[List[str | int]], None] | None</code> <p>The function to call when the value changes.</p> <code>None</code> <code>format_func</code> <code>Callable[[Any], str] | None</code> <p>The function to format the options.</p> <code>None</code> <code>flex_direction</code> <code>Literal['row', 'col']</code> <p>The direction of the checkbox group: \"row\", \"col\".</p> <code>'col'</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the checkbox group.</p> <code>{}</code> <p>Returns:     List[str | int]: The value of the checkbox group.</p> <p>Example:</p> <pre><code>selected_options = ui.checkbox_group(\"Checkbox Group\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=[\"Option 1\"], on_change=lambda value: print(f\"Checkbox group value changed to {value}\"))\nui.text(f\"Selected options: {', '.join(selected_options) if selected_options else 'None'}\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def checkbox_group(\n    self,\n    label: str,\n    options: List[Union[RLOption, str, Dict[str, Any]]],\n    *,\n    value: Optional[List[Any]] = None,\n    key: Optional[str] = None,\n    on_change: Optional[Callable[[List[Any]], None]] = None,\n    format_func: Optional[Callable[[Any], str]] = None,\n    flex_direction: Literal[\"row\", \"col\"] = \"col\",\n    **kwargs: Any,\n) -&gt; List[Any]:\n    \"\"\"\n    Creates a checkbox group with the given label and options.\n\n    Args:\n        label (str): The label of the checkbox group.\n        options (List[RLOption | str | Dict[str, Any]]): The options of the checkbox group. Each option can be a string or a dictionary with the following keys: label, value, caption (optional), disabled (optional).\n        value (List[str | int] | None): The value of the checkbox group.\n        key (str | None): The key of the checkbox group.\n        on_change (Callable[[List[str | int]], None] | None): The function to call when the value changes.\n        format_func (Callable[[Any], str] | None): The function to format the options.\n        flex_direction (Literal[\"row\", \"col\"]): The direction of the checkbox group: \"row\", \"col\".\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the checkbox group.\n    Returns:\n        List[str | int]: The value of the checkbox group.\n\n    Example:\n    ```python\n    selected_options = ui.checkbox_group(\"Checkbox Group\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=[\"Option 1\"], on_change=lambda value: print(f\"Checkbox group value changed to {value}\"))\n    ui.text(f\"Selected options: {', '.join(selected_options) if selected_options else 'None'}\")\n    ```\n    \"\"\"\n    return self._x_checkbox_group(\n        \"checkbox-group\",\n        key or self._new_widget_id(\"checkbox-group\", label),\n        label=label,\n        options=options,\n        value=value,\n        on_change=on_change,\n        format_func=format_func,\n        flexDirection=flex_direction,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.columns","title":"<code>columns(spec, *, key=None, vertical_alignment='top', columns_gap='small')</code>","text":"<p>Creates a flexbox layout with several columns with the given spec.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>int | List[int]</code> <p>The specification of the columns. Can be an integer or a list of integers.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the container.</p> <code>None</code> <code>vertical_alignment</code> <code>VerticalAlignment</code> <p>The vertical alignment of the columns: \"top\", \"center\", \"bottom\".</p> <code>'top'</code> <code>columns_gap</code> <code>ColumnsGap</code> <p>The gap between the columns: \"none\", \"small\", \"medium\", \"large\".</p> <code>'small'</code> <p>Returns:</p> Type Description <code>List[RouteLitBuilder]</code> <p>List[RouteLitBuilder]: A list of builders for the columns.</p> <p>Examples:</p> <pre><code>    # 2 columns with equal width\n    col1, col2 = ui.columns(2)\n    # usage inline\n    col1.text(\"Column 1\")\n    col2.text(\"Column 2\")\n    # usage as context manager\n    with col1:\n        ui.text(\"Column 1\")\n    with col2:\n        ui.text(\"Column 2\")\n    # usage with different widths\n    col1, col2, col3 = ui.columns([2, 1, 1])\n    col1.text(\"Column 1\")\n    col2.text(\"Column 2\")\n    col3.text(\"Column 3\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def columns(\n    self,\n    spec: Union[int, List[int]],\n    *,\n    key: Optional[str] = None,\n    vertical_alignment: VerticalAlignment = \"top\",\n    columns_gap: ColumnsGap = \"small\",\n) -&gt; List[\"RouteLitBuilder\"]:\n    \"\"\"Creates a flexbox layout with several columns with the given spec.\n\n    Args:\n        spec (int | List[int]): The specification of the columns. Can be an integer or a list of integers.\n        key (Optional[str]): The key of the container.\n        vertical_alignment (VerticalAlignment): The vertical alignment of the columns: \"top\", \"center\", \"bottom\".\n        columns_gap (ColumnsGap): The gap between the columns: \"none\", \"small\", \"medium\", \"large\".\n\n    Returns:\n        List[RouteLitBuilder]: A list of builders for the columns.\n\n    Examples:\n    ```python\n        # 2 columns with equal width\n        col1, col2 = ui.columns(2)\n        # usage inline\n        col1.text(\"Column 1\")\n        col2.text(\"Column 2\")\n        # usage as context manager\n        with col1:\n            ui.text(\"Column 1\")\n        with col2:\n            ui.text(\"Column 2\")\n        # usage with different widths\n        col1, col2, col3 = ui.columns([2, 1, 1])\n        col1.text(\"Column 1\")\n        col2.text(\"Column 2\")\n        col3.text(\"Column 3\")\n    ```\n    \"\"\"\n    if isinstance(spec, int):\n        spec = [1] * spec\n    container_key = key or self._new_text_id(\"container\")\n    container = self._create_element(\n        name=\"container\",\n        key=container_key,\n        props={\n            \"className\": \"rl-flex rl-flex-row\",\n            \"style\": {\n                \"alignItems\": verticalAlignmentMap.get(vertical_alignment, \"top\"),\n                \"columnGap\": columnsGapMap.get(columns_gap, \"small\"),\n            },\n        },\n    )\n    container_builder = self._build_nested_builder(container)\n    with container_builder:\n        element_builders = []\n        for column_spec in spec:\n            column = self._create_element(\n                name=\"container\",\n                key=self._new_text_id(\"col\"),\n                props={\"style\": {\"flex\": column_spec}},\n            )\n            element_builders.append(self._build_nested_builder(column))\n    return element_builders\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.container","title":"<code>container(key=None, height=None, **kwargs)</code>","text":"<p>Creates a container component.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[str]</code> <p>The key of the container.</p> <code>None</code> <code>height</code> <code>Optional[str]</code> <p>The height of the container.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the container.</p> <code>{}</code> <p>Example:</p> <pre><code>with ui.container(height=\"100px\"):\n    ui.text(\"Container\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def container(self, key: Optional[str] = None, height: Optional[str] = None, **kwargs: Any) -&gt; \"RouteLitBuilder\":\n    \"\"\"\n    Creates a container component.\n\n    Args:\n        key (Optional[str]): The key of the container.\n        height (Optional[str]): The height of the container.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the container.\n\n    Example:\n    ```python\n    with ui.container(height=\"100px\"):\n        ui.text(\"Container\")\n    ```\n    \"\"\"\n    container = self._create_element(\n        name=\"container\",\n        key=key or self._new_text_id(\"container\"),\n        props={\"style\": {\"height\": height}, **kwargs},\n    )\n    return self._build_nested_builder(container)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.expander","title":"<code>expander(title, *, is_open=None, key=None)</code>","text":"<p>Creates an expander component that can be used as both a context manager and a regular function call.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the expander.</p> required <code>is_open</code> <code>Optional[bool]</code> <p>Whether the expander is open.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>The key of the expander.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>RouteLitBuilder</code> <code>RouteLitBuilder</code> <p>A builder for the expander.</p> <pre><code>Usage:\n    def build_index_view(ui: RouteLitBuilder):\n        # Context manager style\n        with ui.expander(\"Title\"):\n            ui.text(\"Content\")\n\n        with ui.expander(\"Title\", is_open=True) as exp0:\n            exp0.text(\"Content\")\n\n        # Function call style\n        exp = ui.expander(\"Title\")\n        exp.text(\"Content\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def expander(self, title: str, *, is_open: Optional[bool] = None, key: Optional[str] = None) -&gt; \"RouteLitBuilder\":\n    \"\"\"\n    Creates an expander component that can be used as both a context manager and a regular function call.\n\n    Args:\n        title (str): The title of the expander.\n        is_open (Optional[bool]): Whether the expander is open.\n        key (Optional[str]): The key of the expander.\n\n    Returns:\n        RouteLitBuilder: A builder for the expander.\n    ```python\n    Usage:\n        def build_index_view(ui: RouteLitBuilder):\n            # Context manager style\n            with ui.expander(\"Title\"):\n                ui.text(\"Content\")\n\n            with ui.expander(\"Title\", is_open=True) as exp0:\n                exp0.text(\"Content\")\n\n            # Function call style\n            exp = ui.expander(\"Title\")\n            exp.text(\"Content\")\n    ```\n    \"\"\"\n    new_key = key or self._new_widget_id(\"expander\", title)\n    new_element = self._create_element(\n        name=\"expander\",\n        key=new_key,\n        props={\"title\": title, \"open\": is_open},\n    )\n    return self._build_nested_builder(new_element)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.file_input","title":"<code>file_input(label, *, key=None, accept_multiple_files=None, accept=None, **kwargs)</code>","text":"<pre><code>file_input(\n    label: str,\n    *,\n    key: Optional[str] = None,\n    accept_multiple_files: Literal[True],\n    **kwargs: Any,\n) -&gt; Optional[List[IOBase]]\n</code></pre><pre><code>file_input(\n    label: str,\n    *,\n    key: Optional[str] = None,\n    accept_multiple_files: Literal[False],\n    **kwargs: Any,\n) -&gt; Optional[IOBase]\n</code></pre><pre><code>file_input(\n    label: str,\n    *,\n    key: Optional[str] = None,\n    accept_multiple_files: None = None,\n    **kwargs: Any,\n) -&gt; Optional[IOBase]\n</code></pre> <p>Creates a file input component. You'll get the bytes of the uploaded file (BytesIO object). Useful for handling files in memory. Not suitable for large files.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the file input.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the file input.</p> <code>None</code> <code>accept_multiple_files</code> <code>Optional[bool]</code> <p>Whether to accept multiple files.</p> <code>None</code> <code>accept</code> <code>Optional[str]</code> <p>The accept attribute of the file input.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the file input.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[IOBase, List[IOBase], None]</code> <p>Optional[IOBase|List[IOBase]]: The file input component.</p> <p>Example:</p> <pre><code># Multiple files\nfiles = ui.file_input(\"Files\", accept_multiple_files=True, accept=\"text/plain, .txt\")\nif files:\n    for file in files:\n        ui.text(file.read().decode(\"utf-8\"))\n\n# Single file\nsingle_file = ui.file_input(\"Single File\", accept_multiple_files=False, accept=\"text/plain, .txt\")\nif single_file:\n    ui.text(single_file.read().decode(\"utf-8\"))\n\n# Handling images\nimport base64\nimage = ui.file_input(\"Image\", accept=\"image/png\")\nif image:\n    ui.image(src=f\"data:image/png;base64,{base64.b64encode(image.read()).decode('utf-8')}\", width=128)\nif image and ui.button(\"Save image\"):\n    with open(\"image.png\", \"wb\") as f:\n        f.write(image.read())\n        ui.text(\"Image saved\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def file_input(\n    self,\n    label: str,\n    *,\n    key: Optional[str] = None,\n    accept_multiple_files: Optional[bool] = None,\n    accept: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Union[IOBase, List[IOBase], None]:\n    \"\"\"\n    Creates a file input component.\n    You'll get the bytes of the uploaded file (BytesIO object).\n    Useful for handling files in memory. Not suitable for large files.\n\n    Args:\n        label (str): The label of the file input.\n        key (Optional[str]): The key of the file input.\n        accept_multiple_files (Optional[bool]): Whether to accept multiple files.\n        accept (Optional[str]): The accept attribute of the file input.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the file input.\n\n    Returns:\n        Optional[IOBase|List[IOBase]]: The file input component.\n\n    Example:\n    ```python\n    # Multiple files\n    files = ui.file_input(\"Files\", accept_multiple_files=True, accept=\"text/plain, .txt\")\n    if files:\n        for file in files:\n            ui.text(file.read().decode(\"utf-8\"))\n\n    # Single file\n    single_file = ui.file_input(\"Single File\", accept_multiple_files=False, accept=\"text/plain, .txt\")\n    if single_file:\n        ui.text(single_file.read().decode(\"utf-8\"))\n\n    # Handling images\n    import base64\n    image = ui.file_input(\"Image\", accept=\"image/png\")\n    if image:\n        ui.image(src=f\"data:image/png;base64,{base64.b64encode(image.read()).decode('utf-8')}\", width=128)\n    if image and ui.button(\"Save image\"):\n        with open(\"image.png\", \"wb\") as f:\n            f.write(image.read())\n            ui.text(\"Image saved\")\n    ```\n    \"\"\"\n    return self._x_file_input(\n        \"input-file\",\n        key or self._new_widget_id(\"input-file\", label),\n        multiple=accept_multiple_files,\n        label=label,\n        accept=accept,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.flex","title":"<code>flex(direction='col', wrap='nowrap', justify_content='start', align_items='normal', align_content='normal', gap=None, key=None, **kwargs)</code>","text":"<p>Creates a flex container with the given direction, wrap, justify content, align items, align content, gap, and key.</p> Source code in <code>src/routelit/builder.py</code> <pre><code>def flex(\n    self,\n    direction: Literal[\"row\", \"col\"] = \"col\",\n    wrap: Literal[\"wrap\", \"nowrap\"] = \"nowrap\",\n    justify_content: Literal[\"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\"] = \"start\",\n    align_items: Literal[\"normal\", \"start\", \"end\", \"center\", \"baseline\", \"stretch\"] = \"normal\",\n    align_content: Literal[\"normal\", \"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\"] = \"normal\",\n    gap: Optional[str] = None,\n    key: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; \"RouteLitBuilder\":\n    \"\"\"\n    Creates a flex container with the given direction, wrap, justify content, align items, align content, gap, and key.\n    \"\"\"\n    container = self._create_element(\n        name=\"flex\",\n        key=key or self._new_text_id(\"flex\"),\n        props={\n            \"direction\": direction,\n            \"flexWrap\": wrap,\n            \"justifyContent\": justify_content,\n            \"alignItems\": align_items,\n            \"alignContent\": align_content,\n            \"gap\": gap,\n            **kwargs,\n        },\n    )\n    return self._build_nested_builder(container)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.form","title":"<code>form(key)</code>","text":"<p>Creates a form area that do not submit input values to the server until the form is submitted. Use button(..., event_name=\"submit\") to submit the form.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the form.</p> required <p>Returns:</p> Name Type Description <code>RouteLitBuilder</code> <code>RouteLitBuilder</code> <p>A builder for the form.</p> <p>Example:</p> <pre><code>with ui.form(\"login\"):\n    username = ui.text_input(\"Username\")\n    password = ui.text_input(\"Password\", type=\"password\")\n    is_submitted = ui.button(\"Login\", event_name=\"submit\")\n    if is_submitted:\n        ui.text(f\"Login successful for {username}\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def form(self, key: str) -&gt; \"RouteLitBuilder\":\n    \"\"\"\n    Creates a form area that do not submit input values to the server until the form is submitted.\n    Use button(..., event_name=\"submit\") to submit the form.\n\n    Args:\n        key (str): The key of the form.\n\n    Returns:\n        RouteLitBuilder: A builder for the form.\n\n    Example:\n    ```python\n    with ui.form(\"login\"):\n        username = ui.text_input(\"Username\")\n        password = ui.text_input(\"Password\", type=\"password\")\n        is_submitted = ui.button(\"Login\", event_name=\"submit\")\n        if is_submitted:\n            ui.text(f\"Login successful for {username}\")\n    ```\n    \"\"\"\n    form = self._create_element(\n        name=\"form\",\n        key=key,\n        props={\"id\": key},\n        virtual=True,\n    )\n    return self._build_nested_builder(form)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.form_submit_button","title":"<code>form_submit_button(text, *, key=None, on_click=None, **kwargs)</code>","text":"<p>Creates a form submit button with the given text, key, on click, and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text of the button.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the button.</p> <code>None</code> <code>on_click</code> <code>Optional[Callable[[], None]]</code> <p>The function to call when the button is clicked.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the button.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the button was clicked.</p> <p>Example:</p> <pre><code>with ui.form(key=\"form_key\"):\n    is_submitted = ui.form_submit_button(\"Submit\", on_click=lambda: print(\"Form submitted\"))\n    if is_submitted:\n        ui.text(\"Form submitted\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def form_submit_button(\n    self,\n    text: str,\n    *,\n    key: Optional[str] = None,\n    on_click: Optional[Callable[[], None]] = None,\n    **kwargs: Any,\n) -&gt; bool:\n    \"\"\"\n    Creates a form submit button with the given text, key, on click, and keyword arguments.\n\n    Args:\n        text (str): The text of the button.\n        key (Optional[str]): The key of the button.\n        on_click (Optional[Callable[[], None]]): The function to call when the button is clicked.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the button.\n\n    Returns:\n        bool: Whether the button was clicked.\n\n    Example:\n    ```python\n    with ui.form(key=\"form_key\"):\n        is_submitted = ui.form_submit_button(\"Submit\", on_click=lambda: print(\"Form submitted\"))\n        if is_submitted:\n            ui.text(\"Form submitted\")\n    ```\n    \"\"\"\n    return self._x_button(\"button\", text, event_name=\"submit\", key=key, on_click=on_click, **kwargs)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.header","title":"<code>header(body, key=None, **kwargs)</code>","text":"<p>Creates a header component.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The body of the header.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the header.</p> <code>None</code> <p>Example:</p> <pre><code>ui.header(\"Header\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def header(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Creates a header component.\n\n    Args:\n        body (str): The body of the header.\n        key (Optional[str]): The key of the header.\n\n    Example:\n    ```python\n    ui.header(\"Header\")\n    ```\n    \"\"\"\n    self._create_element(\n        name=\"header\",\n        key=key or self._new_text_id(\"header\"),\n        props={\"children\": body, **kwargs},\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.hr","title":"<code>hr(key=None, **kwargs)</code>","text":"<p>Creates a horizontal rule.</p> Source code in <code>src/routelit/builder.py</code> <pre><code>def hr(self, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Creates a horizontal rule.\n    \"\"\"\n    self._create_element(name=\"hr\", key=key or self._new_text_id(\"hr\"), props=kwargs)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.image","title":"<code>image(src, *, key=None, **kwargs)</code>","text":"<p>Creates an image component.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>The source of the image.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the image.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the image.</p> <code>{}</code> <p>Example:</p> <pre><code>ui.image(\"https://www.google.com/favicon.ico\", alt=\"Google\", width=\"24px\", height=\"24px\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def image(self, src: str, *, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Creates an image component.\n\n    Args:\n        src (str): The source of the image.\n        key (Optional[str]): The key of the image.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the image.\n\n    Example:\n    ```python\n    ui.image(\"https://www.google.com/favicon.ico\", alt=\"Google\", width=\"24px\", height=\"24px\")\n    ```\n    \"\"\"\n    self._create_element(\n        name=\"image\",\n        key=key or self._new_text_id(\"image\"),\n        props={\"src\": src, **kwargs},\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.link","title":"<code>link(href, text='', *, replace=False, is_external=False, key=None, rl_element_type='link', rl_text_attr='text', rl_virtual=None, **kwargs)</code>","text":"<p>Creates a link component. Use this to navigate to a different page.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The href of the link.</p> required <code>text</code> <code>str</code> <p>The text of the link.</p> <code>''</code> <code>replace</code> <code>bool</code> <p>Whether to replace the current page from the history.</p> <code>False</code> <code>is_external</code> <code>bool</code> <p>Whether the link is external to the current app.</p> <code>False</code> <code>key</code> <code>Optional[str]</code> <p>The key of the link.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the link.</p> <code>{}</code> <p>Example:</p> <pre><code>ui.link(\"/signup\", text=\"Signup\")\nui.link(\"/login\", text=\"Login\", replace=True)\nui.link(\"https://www.google.com\", text=\"Google\", is_external=True)\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def link(\n    self,\n    href: str,\n    text: str = \"\",\n    *,\n    replace: bool = False,\n    is_external: bool = False,\n    key: Optional[str] = None,\n    rl_element_type: str = \"link\",\n    rl_text_attr: str = \"text\",\n    rl_virtual: Optional[bool] = None,\n    **kwargs: Any,\n) -&gt; RouteLitElement:\n    \"\"\"\n    Creates a link component. Use this to navigate to a different page.\n\n    Args:\n        href (str): The href of the link.\n        text (str): The text of the link.\n        replace (bool): Whether to replace the current page from the history.\n        is_external (bool): Whether the link is external to the current app.\n        key (Optional[str]): The key of the link.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the link.\n\n    Example:\n    ```python\n    ui.link(\"/signup\", text=\"Signup\")\n    ui.link(\"/login\", text=\"Login\", replace=True)\n    ui.link(\"https://www.google.com\", text=\"Google\", is_external=True)\n    ```\n    \"\"\"\n    new_element = self._create_element(\n        name=rl_element_type,\n        key=key or self._new_text_id(rl_element_type),\n        props={\n            \"href\": href,\n            \"replace\": replace,\n            \"isExternal\": is_external,\n            rl_text_attr: text,\n            **kwargs,\n        },\n        virtual=rl_virtual,\n    )\n    return new_element\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.link_area","title":"<code>link_area(href, replace=False, is_external=False, key=None, className=None, **kwargs)</code>","text":"<p>Creates a link area component. Use this element which is a container of other elements.</p> <p>Parameters:</p> Name Type Description Default <code>href</code> <code>str</code> <p>The href of the link.</p> required <code>replace</code> <code>bool</code> <p>Whether to replace the current page.</p> <code>False</code> <code>is_external</code> <code>bool</code> <p>Whether the link is external.</p> <code>False</code> <code>key</code> <code>Optional[str]</code> <p>The key of the link area.</p> <code>None</code> <code>className</code> <code>Optional[str]</code> <p>The class name of the link area.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the link area.</p> <code>{}</code> <p>Example:</p> <pre><code>with ui.link_area(\"https://www.google.com\"):\n    with ui.flex(direction=\"row\", gap=\"small\"):\n        ui.image(\"https://www.google.com/favicon.ico\", width=\"24px\", height=\"24px\")\n        ui.text(\"Google\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def link_area(\n    self,\n    href: str,\n    replace: bool = False,\n    is_external: bool = False,\n    key: Optional[str] = None,\n    className: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; \"RouteLitBuilder\":\n    \"\"\"\n    Creates a link area component. Use this element which is a container of other elements.\n\n    Args:\n        href (str): The href of the link.\n        replace (bool): Whether to replace the current page.\n        is_external (bool): Whether the link is external.\n        key (Optional[str]): The key of the link area.\n        className (Optional[str]): The class name of the link area.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the link area.\n\n    Example:\n    ```python\n    with ui.link_area(\"https://www.google.com\"):\n        with ui.flex(direction=\"row\", gap=\"small\"):\n            ui.image(\"https://www.google.com/favicon.ico\", width=\"24px\", height=\"24px\")\n            ui.text(\"Google\")\n    ```\n    \"\"\"\n    link_element = self.link(\n        href,\n        replace=replace,\n        is_external=is_external,\n        key=key,\n        className=f\"rl-no-link-decoration {className or ''}\",\n        **kwargs,\n    )\n    return self._build_nested_builder(link_element)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.markdown","title":"<code>markdown(body, *, allow_unsafe_html=False, key=None, **kwargs)</code>","text":"<p>Creates a markdown component.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The body of the markdown.</p> required <code>allow_unsafe_html</code> <code>bool</code> <p>Whether to allow unsafe HTML.</p> <code>False</code> <code>key</code> <code>Optional[str]</code> <p>The key of the markdown.</p> <code>None</code> <p>Example:</p> <pre><code>ui.markdown(\"**Bold** *italic* [link](https://www.google.com)\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def markdown(\n    self,\n    body: str,\n    *,\n    allow_unsafe_html: bool = False,\n    key: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Creates a markdown component.\n\n    Args:\n        body (str): The body of the markdown.\n        allow_unsafe_html (bool): Whether to allow unsafe HTML.\n        key (Optional[str]): The key of the markdown.\n\n    Example:\n    ```python\n    ui.markdown(\"**Bold** *italic* [link](https://www.google.com)\")\n    ```\n    \"\"\"\n    self._create_element(\n        name=\"markdown\",\n        key=key or self._new_text_id(\"markdown\"),\n        props={\"body\": body, \"allowUnsafeHtml\": allow_unsafe_html, **kwargs},\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.radio","title":"<code>radio(label, options, *, value=None, key=None, on_change=None, flex_direction='col', format_func=None, **kwargs)</code>","text":"<p>Creates a radio group with the given label and options.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the radio group.</p> required <code>options</code> <code>List[RLOption | str | Dict[str, Any]]</code> <p>The options of the radio group. Each option can be a string or a dictionary with the following keys: - label: The label of the option. - value: The value of the option. - caption: The caption of the option. - disabled: Whether the option is disabled.</p> required <code>value</code> <code>str | int | None</code> <p>The value of the radio group.</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key of the radio group.</p> <code>None</code> <code>on_change</code> <code>Callable[[str | int | None], None] | None</code> <p>The function to call when the value changes. The function will be called with the new value.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the radio group.</p> <code>{}</code> <p>Returns:     str | int | None: The value of the selected radio option.</p> <p>Example:</p> <pre><code>value = ui.radio(\"Radio\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=\"Option 1\", on_change=lambda value: print(f\"Radio value changed to {value}\"))\nui.text(f\"Radio value is {value}\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def radio(\n    self,\n    label: str,\n    options: List[Union[RLOption, str, Dict[str, Any]]],\n    *,\n    value: Optional[Any] = None,\n    key: Optional[str] = None,\n    on_change: Optional[Callable[[Any], None]] = None,\n    flex_direction: Literal[\"row\", \"col\"] = \"col\",\n    format_func: Optional[Callable[[Any], str]] = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"\n    Creates a radio group with the given label and options.\n\n    Args:\n        label (str): The label of the radio group.\n        options (List[RLOption | str | Dict[str, Any]]): The options of the radio group. Each option can be a string or a dictionary with the following keys:\n            - label: The label of the option.\n            - value: The value of the option.\n            - caption: The caption of the option.\n            - disabled: Whether the option is disabled.\n        value (str | int | None): The value of the radio group.\n        key (str | None): The key of the radio group.\n        on_change (Callable[[str | int | None], None] | None): The function to call when the value changes. The function will be called with the new value.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the radio group.\n    Returns:\n        str | int | None: The value of the selected radio option.\n\n    Example:\n    ```python\n    value = ui.radio(\"Radio\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=\"Option 1\", on_change=lambda value: print(f\"Radio value changed to {value}\"))\n    ui.text(f\"Radio value is {value}\")\n    ```\n    \"\"\"\n    return self._x_radio_select(\n        \"radio\",\n        key or self._new_widget_id(\"radio\", label),\n        options=options,\n        value=value,\n        on_change=on_change,\n        label=label,\n        format_func=format_func,\n        flexDirection=flex_direction,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.rerun","title":"<code>rerun(scope='auto', clear_event=True)</code>","text":"<p>Reruns the current page. Use this to rerun the app or the fragment depending on the context.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>RerunType</code> <p>The scope of the rerun. \"auto\" will rerun the app or the fragment depending on the context, \"app\" will rerun the entire app</p> <code>'auto'</code> <code>clear_event</code> <code>bool</code> <p>Whether to clear the event.</p> <code>True</code> <p>Example:</p> <pre><code>counter = ui.session_state.get(\"counter\", 0)\nui.text(f\"Counter is {counter}\")\nshould_increase = ui.button(\"Increment\")\nif should_increase:\n    ui.session_state[\"counter\"] = counter + 1\n    ui.rerun()\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def rerun(self, scope: RerunType = \"auto\", clear_event: bool = True) -&gt; None:\n    \"\"\"\n    Reruns the current page. Use this to rerun the app or the fragment depending on the context.\n\n    Args:\n        scope (RerunType): The scope of the rerun. \"auto\" will rerun the app or the fragment depending on the context, \"app\" will rerun the entire app\n        clear_event (bool): Whether to clear the event.\n\n    Example:\n    ```python\n    counter = ui.session_state.get(\"counter\", 0)\n    ui.text(f\"Counter is {counter}\")\n    should_increase = ui.button(\"Increment\")\n    if should_increase:\n        ui.session_state[\"counter\"] = counter + 1\n        ui.rerun()\n    ```\n    \"\"\"\n    if self.should_rerun_event:\n        self.should_rerun_event.set()\n    if clear_event:\n        self.request.clear_event()\n    if scope == \"app\":\n        self.request.clear_fragment_id()\n    target = \"app\" if scope == \"app\" else self.initial_target\n    # when running in stream mode, we need to schedule the rerun action to the event queue\n    # so that the rerun action would be got with event queue loop can be cancelled\n    if self._schedule_event(RerunAction(address=[-1], target=target)):\n        return\n    raise RerunException(self.session_state.get_data(), scope=scope)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.select","title":"<code>select(label, options, *, value='', key=None, on_change=None, format_func=None, **kwargs)</code>","text":"<p>Creates a select dropdown with the given label and options.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the select dropdown.</p> required <code>options</code> <code>List[RLOption | str | Dict[str, Any]]</code> <p>The options of the select dropdown. Each option can be a string or a dictionary with the following keys: (label, value, disabled) - label: The label of the option. - value: The value of the option. - disabled: Whether the option is disabled.</p> required <code>value</code> <code>str | int</code> <p>The value of the select dropdown.</p> <code>''</code> <code>key</code> <code>str | None</code> <p>The key of the select dropdown.</p> <code>None</code> <code>on_change</code> <code>Callable[[str | int | None], None] | None</code> <p>The function to call when the value changes. The function will be called with the new value.</p> <code>None</code> <code>format_func</code> <code>Callable[[Any], str] | None</code> <p>The function to format the options.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the select dropdown.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value of the select dropdown.</p> <p>Example:</p> <pre><code>value = ui.select(\"Select\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=\"Option 1\", on_change=lambda value: print(f\"Select value changed to {value}\"))\nui.text(f\"Select value is {value}\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def select(\n    self,\n    label: str,\n    options: List[Union[RLOption, str, Dict[str, Any]]],\n    *,\n    value: Any = \"\",\n    key: Optional[str] = None,\n    on_change: Optional[Callable[[Any], None]] = None,\n    format_func: Optional[Callable[[Any], str]] = None,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"\n    Creates a select dropdown with the given label and options.\n\n    Args:\n        label (str): The label of the select dropdown.\n        options (List[RLOption | str | Dict[str, Any]]): The options of the select dropdown. Each option can be a string or a dictionary with the following keys: (label, value, disabled)\n            - label: The label of the option.\n            - value: The value of the option.\n            - disabled: Whether the option is disabled.\n        value (str | int): The value of the select dropdown.\n        key (str | None): The key of the select dropdown.\n        on_change (Callable[[str | int | None], None] | None): The function to call when the value changes. The function will be called with the new value.\n        format_func (Callable[[Any], str] | None): The function to format the options.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the select dropdown.\n\n    Returns:\n        Any: The value of the select dropdown.\n\n    Example:\n    ```python\n    value = ui.select(\"Select\", options=[\"Option 1\", {\"label\": \"Option 2\", \"value\": \"option2\"}, {\"label\": \"Option 3\", \"value\": \"option3\", \"disabled\": True}], value=\"Option 1\", on_change=lambda value: print(f\"Select value changed to {value}\"))\n    ui.text(f\"Select value is {value}\")\n    ```\n    \"\"\"\n    return self._x_radio_select(\n        \"select\",\n        key or self._new_widget_id(\"select\", label),\n        options=options,\n        value=value,\n        on_change=on_change,\n        format_func=format_func,\n        label=label,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.set_page_config","title":"<code>set_page_config(page_title=None, page_description=None)</code>","text":"<p>Sets the page title and description.</p> <p>Parameters:</p> Name Type Description Default <code>page_title</code> <code>str | None</code> <p>The title of the page.</p> <code>None</code> <code>page_description</code> <code>str | None</code> <p>The description of the page.</p> <code>None</code> Source code in <code>src/routelit/builder.py</code> <pre><code>def set_page_config(self, page_title: Optional[str] = None, page_description: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Sets the page title and description.\n\n    Args:\n        page_title (str | None): The title of the page.\n        page_description (str | None): The description of the page.\n    \"\"\"\n    self.head = Head(title=page_title, description=page_description)\n    self._create_element(\n        name=\"head\",\n        key=\"__head__\",\n        props={\n            \"title\": page_title,\n            \"description\": page_description,\n        },\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.subheader","title":"<code>subheader(body, key=None, **kwargs)</code>","text":"<p>Creates a subheader component.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The body of the subheader.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the subheader.</p> <code>None</code> <p>Example:</p> <pre><code>ui.subheader(\"Subheader\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def subheader(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Creates a subheader component.\n\n    Args:\n        body (str): The body of the subheader.\n        key (Optional[str]): The key of the subheader.\n\n    Example:\n    ```python\n    ui.subheader(\"Subheader\")\n    ```\n    \"\"\"\n    self._create_element(\n        name=\"subheader\",\n        key=key or self._new_text_id(\"subheader\"),\n        props={\"children\": body, **kwargs},\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.text","title":"<code>text(body, key=None, **kwargs)</code>","text":"<p>Creates a text component.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The body of the text.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the text.</p> <code>None</code> <p>Example:</p> <pre><code>ui.text(\"Text\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def text(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Creates a text component.\n\n    Args:\n        body (str): The body of the text.\n        key (Optional[str]): The key of the text.\n\n    Example:\n    ```python\n    ui.text(\"Text\")\n    ```\n    \"\"\"\n    self.markdown(body, allow_unsafe_html=False, key=key, **kwargs)\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.text_input","title":"<code>text_input(label, *, type='text', value=None, key=None, on_change=None, **kwargs)</code>","text":"<p>Creates a text input with the given label and value.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the text input.</p> required <code>type</code> <code>TextInputType</code> <p>The type of the text input.</p> <code>'text'</code> <code>value</code> <code>Optional[str]</code> <p>The value of the text input.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>The key of the text input.</p> <code>None</code> <code>on_change</code> <code>Optional[Callable[[str], None]]</code> <p>The function to call when the value changes. The function will be called with the new value.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the text input.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The text value of the text input.</p> <p>Example:</p> <pre><code>name = ui.text_input(\"Name\", value=\"John\", on_change=lambda value: print(f\"Name changed to {value}\"))\nui.text(f\"Name is {name}\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def text_input(\n    self,\n    label: str,\n    *,\n    type: TextInputType = \"text\",\n    value: Optional[str] = None,\n    key: Optional[str] = None,\n    on_change: Optional[Callable[[str], None]] = None,\n    **kwargs: Any,\n) -&gt; Optional[str]:\n    \"\"\"\n    Creates a text input with the given label and value.\n\n    Args:\n        label (str): The label of the text input.\n        type (TextInputType): The type of the text input.\n        value (Optional[str]): The value of the text input.\n        key (Optional[str]): The key of the text input.\n        on_change (Optional[Callable[[str], None]]): The function to call when the value changes. The function will be called with the new value.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the text input.\n\n    Returns:\n        str: The text value of the text input.\n\n    Example:\n    ```python\n    name = ui.text_input(\"Name\", value=\"John\", on_change=lambda value: print(f\"Name changed to {value}\"))\n    ui.text(f\"Name is {name}\")\n    ```\n    \"\"\"\n    return self._x_input(\n        \"single-text-input\",\n        key or self._new_widget_id(\"text-input\", label),\n        value=value,\n        on_change=on_change,\n        type=type,\n        label=label,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.textarea","title":"<code>textarea(label, *, value=None, key=None, on_change=None, **kwargs)</code>","text":"<p>Creates a textarea with the given label and value.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the textarea.</p> required <code>value</code> <code>Optional[str]</code> <p>The value of the textarea.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>The key of the textarea.</p> <code>None</code> <code>on_change</code> <code>Optional[Callable[[str], None]]</code> <p>The function to call when the value changes. The function will be called with the new value.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to pass to the textarea.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The text value of the textarea.</p> <p>Example:</p> <pre><code>text = ui.textarea(\"Text\", value=\"Hello, world!\", on_change=lambda value: print(f\"Text changed to {value}\"))\nui.text(f\"Text is {text}\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def textarea(\n    self,\n    label: str,\n    *,\n    value: Optional[str] = None,\n    key: Optional[str] = None,\n    on_change: Optional[Callable[[str], None]] = None,\n    **kwargs: Any,\n) -&gt; Optional[str]:\n    \"\"\"\n    Creates a textarea with the given label and value.\n\n    Args:\n        label (str): The label of the textarea.\n        value (Optional[str]): The value of the textarea.\n        key (Optional[str]): The key of the textarea.\n        on_change (Optional[Callable[[str], None]]): The function to call when the value changes. The function will be called with the new value.\n        kwargs (Dict[str, Any]): The keyword arguments to pass to the textarea.\n\n    Returns:\n        str: The text value of the textarea.\n\n    Example:\n    ```python\n    text = ui.textarea(\"Text\", value=\"Hello, world!\", on_change=lambda value: print(f\"Text changed to {value}\"))\n    ui.text(f\"Text is {text}\")\n    ```\n    \"\"\"\n    return self._x_input(\n        \"single-textarea\",\n        key or self._new_widget_id(\"textarea\", label),\n        value=value,\n        on_change=on_change,\n        label=label,\n        **kwargs,\n    )\n</code></pre>"},{"location":"modules/#routelit.builder.RouteLitBuilder.title","title":"<code>title(body, key=None, **kwargs)</code>","text":"<p>Creates a title component.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The body of the title.</p> required <code>key</code> <code>Optional[str]</code> <p>The key of the title.</p> <code>None</code> <p>Example:</p> <pre><code>ui.title(\"Title\")\n</code></pre> Source code in <code>src/routelit/builder.py</code> <pre><code>def title(self, body: str, key: Optional[str] = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Creates a title component.\n\n    Args:\n        body (str): The body of the title.\n        key (Optional[str]): The key of the title.\n\n    Example:\n    ```python\n    ui.title(\"Title\")\n    ```\n    \"\"\"\n    self._create_element(\n        name=\"title\",\n        key=key or self._new_text_id(\"title\"),\n        props={\"children\": body, **kwargs},\n    )\n</code></pre>"},{"location":"modules/#domain-module","title":"Domain Module","text":""},{"location":"modules/#routelit.domain.ActionGenerator","title":"<code>ActionGenerator = AsyncGenerator[Action, None]</code>  <code>module-attribute</code>","text":"<p>Async generator type for Action instances.</p>"},{"location":"modules/#routelit.domain.COOKIE_SESSION_KEY","title":"<code>COOKIE_SESSION_KEY = 'ROUTELIT_SESSION_ID'</code>  <code>module-attribute</code>","text":"<p>The key of the session id in the cookie.</p>"},{"location":"modules/#routelit.domain.RerunType","title":"<code>RerunType = Literal['auto', 'app', 'fragment']</code>  <code>module-attribute</code>","text":"<p>\"auto\" will rerun the fragment if it is called from a fragment otherwise it will rerun the app. \"app\" will rerun the app.</p>"},{"location":"modules/#routelit.domain.RouteLitElementGenerator","title":"<code>RouteLitElementGenerator = AsyncGenerator[RouteLitElement, None]</code>  <code>module-attribute</code>","text":"<p>Async generator type for RouteLitElement instances.</p>"},{"location":"modules/#routelit.domain.Action","title":"<code>Action</code>  <code>dataclass</code>","text":"Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass Action:\n    address: Optional[List[int]]\n    \"\"\"\n      (List[int]) The address is the list of indices to the array tree of elements in the session state\n      from the root to the target element.\n    \"\"\"\n    target: Optional[Literal[\"app\", \"fragment\"]]\n    \"\"\"\n      (Literal[\"app\", \"fragment\"]) The target is the target of the action.\n      If None, the action is applied to the app.\n    \"\"\"\n</code></pre>"},{"location":"modules/#routelit.domain.Action.address","title":"<code>address</code>  <code>instance-attribute</code>","text":"<p>(List[int]) The address is the list of indices to the array tree of elements in the session state from the root to the target element.</p>"},{"location":"modules/#routelit.domain.Action.target","title":"<code>target</code>  <code>instance-attribute</code>","text":"<p>(Literal[\"app\", \"fragment\"]) The target is the target of the action. If None, the action is applied to the app.</p>"},{"location":"modules/#routelit.domain.ActionsResponse","title":"<code>ActionsResponse</code>  <code>dataclass</code>","text":"<p>The actions to be executed by the RouteLit app.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass ActionsResponse:\n    \"\"\"\n    The actions to be executed by the RouteLit app.\n    \"\"\"\n\n    actions: List[Action]\n    target: Literal[\"app\", \"fragment\"]\n</code></pre>"},{"location":"modules/#routelit.domain.AddAction","title":"<code>AddAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to add an element.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass AddAction(Action):\n    \"\"\"\n    The action to add an element.\n    \"\"\"\n\n    element: RouteLitElement\n    key: str\n    type: Literal[\"add\"] = \"add\"\n</code></pre>"},{"location":"modules/#routelit.domain.FreshBoundaryAction","title":"<code>FreshBoundaryAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to mark the fresh boundary of the app or fragment. It means all elements after this action should be stale. This action should be used when streaming, should be just before the first action.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass FreshBoundaryAction(Action):\n    \"\"\"\n    The action to mark the fresh boundary of the app or fragment.\n    It means all elements after this action should be stale.\n    This action should be used when streaming, should be just before the first action.\n    \"\"\"\n\n    type: Literal[\"fresh_boundary\"] = \"fresh_boundary\"\n</code></pre>"},{"location":"modules/#routelit.domain.LastAction","title":"<code>LastAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to mark that no more actions will be yielded after this action.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass LastAction(Action):\n    \"\"\"\n    The action to mark that no more actions will be yielded after this action.\n    \"\"\"\n\n    type: Literal[\"last\"] = \"last\"\n</code></pre>"},{"location":"modules/#routelit.domain.NoChangeAction","title":"<code>NoChangeAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to mark that no change will be made.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass NoChangeAction(Action):\n    \"\"\"\n    The action to mark that no change will be made.\n    \"\"\"\n\n    type: Literal[\"no_change\"] = \"no_change\"\n</code></pre>"},{"location":"modules/#routelit.domain.RemoveAction","title":"<code>RemoveAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to remove an element.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass RemoveAction(Action):\n    \"\"\"\n    The action to remove an element.\n    \"\"\"\n\n    key: str\n    type: Literal[\"remove\"] = \"remove\"\n</code></pre>"},{"location":"modules/#routelit.domain.RouteLitElement","title":"<code>RouteLitElement</code>  <code>dataclass</code>","text":"<p>The element to be rendered by the RouteLit app.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass RouteLitElement:\n    \"\"\"\n    The element to be rendered by the RouteLit app.\n    \"\"\"\n\n    ROOT_ELEMENT_NAME: ClassVar[str] = \"RLRoot\"\n\n    name: str\n    props: Dict[str, Any]\n    key: str\n    children: Optional[List[\"RouteLitElement\"]] = None\n    address: Optional[List[int]] = None\n    virtual: Optional[bool] = None\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"props\": self.props,\n            \"key\": self.key,\n            \"address\": self.address,\n            \"virtual\": self.virtual,\n        }\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"RouteLitElement\":\n        return RouteLitElement(\n            name=data[\"name\"],\n            props=data[\"props\"],\n            key=data[\"key\"],\n            children=data.get(\"children\"),\n            address=data.get(\"address\"),\n            virtual=data.get(\"virtual\"),\n        )\n\n    @staticmethod\n    def create_root_element() -&gt; \"RouteLitElement\":\n        return RouteLitElement(\n            name=RouteLitElement.ROOT_ELEMENT_NAME,\n            props={},\n            key=\"\",\n            children=[],\n            address=None,\n            virtual=True,\n        )\n\n    def append_child(self, child: \"RouteLitElement\") -&gt; None:\n        if self.children is None:\n            self.children = []\n        self.children.append(child)\n\n    def get_children(self) -&gt; List[\"RouteLitElement\"]:\n        if self.children is None:\n            self.children = []\n        return self.children\n</code></pre>"},{"location":"modules/#routelit.domain.RouteLitEvent","title":"<code>RouteLitEvent</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>The event to be executed by the RouteLit app.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>class RouteLitEvent(TypedDict):\n    \"\"\"\n    The event to be executed by the RouteLit app.\n    \"\"\"\n\n    type: Literal[\"click\", \"changed\", \"navigate\"]\n    componentId: str\n    data: Dict[str, Any]\n    formId: Optional[str]\n    files: Optional[List[IOBase]]\n    \"\"\"\n    The files to be uploaded.\n    \"\"\"\n</code></pre>"},{"location":"modules/#routelit.domain.RouteLitEvent.files","title":"<code>files</code>  <code>instance-attribute</code>","text":"<p>The files to be uploaded.</p>"},{"location":"modules/#routelit.domain.RouteLitRequest","title":"<code>RouteLitRequest</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The request class for the RouteLit app. This class should be implemented by the web framework you want to integrate with.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>class RouteLitRequest(ABC):\n    \"\"\"\n    The request class for the RouteLit app.\n    This class should be implemented by the web framework you want to integrate with.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._ui_event = self._get_ui_event()\n        self._fragment_id = self._get_fragment_id()\n\n    @abstractmethod\n    def get_headers(self) -&gt; Dict[str, str]:\n        pass\n\n    @abstractmethod\n    def get_path_params(self) -&gt; Optional[Mapping[str, Any]]:\n        pass\n\n    @abstractmethod\n    def get_referrer(self) -&gt; Optional[str]:\n        pass\n\n    @abstractmethod\n    def is_json(self) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def is_multipart(self) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def get_json(self) -&gt; Optional[Dict[str, Any]]:\n        pass\n\n    @abstractmethod\n    def get_files(self) -&gt; Optional[list[IOBase]]:\n        pass\n\n    def _get_internal_referrer(self) -&gt; Optional[str]:\n        return self.get_headers().get(\"X-Referer\") or self.get_referrer()\n\n    def _get_ui_event(self) -&gt; Optional[RouteLitEvent]:\n        if self.is_json() and (json_data := self.get_json()) and isinstance(json_data, dict):\n            return json_data.get(\"uiEvent\")\n        if self.is_multipart() and (json_data := self.get_json()) and isinstance(json_data, dict):\n            body = json_data.get(\"uiEvent\", {}) or {}\n            if \"data\" not in body:\n                body[\"data\"] = {}\n            maybe_files = self.get_files()\n            body[\"data\"][\"files\"] = (\n                [BytesIO(file.read()) for file in maybe_files] if isinstance(maybe_files, list) else maybe_files\n            )\n            return cast(RouteLitEvent, body)\n        else:\n            return None\n\n    @property\n    def ui_event(self) -&gt; Optional[RouteLitEvent]:\n        return self._ui_event\n\n    def clear_event(self) -&gt; None:\n        self._ui_event = None\n\n    @abstractmethod\n    def get_query_param(self, key: str) -&gt; Optional[str]:\n        pass\n\n    @abstractmethod\n    def get_query_param_list(self, key: str) -&gt; List[str]:\n        pass\n\n    @abstractmethod\n    def get_session_id(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def get_pathname(self) -&gt; str:\n        pass\n\n    @abstractmethod\n    def get_host(self) -&gt; str:\n        pass\n\n    @property\n    @abstractmethod\n    def method(self) -&gt; str:\n        pass\n\n    def clear_fragment_id(self) -&gt; None:\n        self._fragment_id = None\n\n    def _get_fragment_id(self) -&gt; Optional[str]:\n        if not self.is_json():\n            return None\n        json_data = self.get_json()\n        if isinstance(json_data, dict):\n            return json_data.get(\"fragmentId\")\n        return None\n\n    @property\n    def fragment_id(self) -&gt; Optional[str]:\n        return self._fragment_id\n\n    def get_host_pathname(self, use_referer: bool = False) -&gt; str:\n        if use_referer:\n            referrer = self._get_internal_referrer()\n            if referrer:\n                url = urlparse(referrer)\n                if url.netloc and url.path:\n                    return url.netloc + url.path\n        return self.get_host() + self.get_pathname()\n\n    def get_session_keys(self, use_referer: bool = False) -&gt; SessionKeys:\n        session_id = self.get_session_id()\n        host_pathname = self.get_host_pathname(use_referer)\n        ui_session_key = f\"{session_id}:{host_pathname}:ui\"\n        session_state_key = f\"{session_id}:{host_pathname}:state\"\n        fragment_addresses_key = f\"{ui_session_key}:fragments\"\n        fragment_params_key = f\"{ui_session_key}:fragment_params\"\n        view_tasks_key = f\"{ui_session_key}:view_tasks\"\n        return SessionKeys(\n            ui_session_key,\n            session_state_key,\n            fragment_addresses_key,\n            fragment_params_key,\n            view_tasks_key,\n        )\n</code></pre>"},{"location":"modules/#routelit.domain.SessionKeys","title":"<code>SessionKeys</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The keys to the session state of the RouteLit app.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>class SessionKeys(NamedTuple):\n    \"\"\"\n    The keys to the session state of the RouteLit app.\n    \"\"\"\n\n    ui_key: str\n    state_key: str\n    fragment_addresses_key: str\n    \"\"\"\n      Key to the addresses of the fragments in the session state.\n      The address is a List of indices to the array tree of elements in the session state\n      from the root to the target element.\n    \"\"\"\n    fragment_params_key: str\n    \"\"\"\n      Key to the parameters of the fragments in the session state.\n    \"\"\"\n    view_tasks_key: str\n    \"\"\"\n      Key to the view tasks in the session state.\n    \"\"\"\n</code></pre>"},{"location":"modules/#routelit.domain.SessionKeys.fragment_addresses_key","title":"<code>fragment_addresses_key</code>  <code>instance-attribute</code>","text":"<p>Key to the addresses of the fragments in the session state. The address is a List of indices to the array tree of elements in the session state from the root to the target element.</p>"},{"location":"modules/#routelit.domain.SessionKeys.fragment_params_key","title":"<code>fragment_params_key</code>  <code>instance-attribute</code>","text":"<p>Key to the parameters of the fragments in the session state.</p>"},{"location":"modules/#routelit.domain.SessionKeys.view_tasks_key","title":"<code>view_tasks_key</code>  <code>instance-attribute</code>","text":"<p>Key to the view tasks in the session state.</p>"},{"location":"modules/#routelit.domain.SetAction","title":"<code>SetAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to set an element.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass SetAction(Action):\n    \"\"\"\n    The action to set an element.\n    \"\"\"\n\n    address: List[int]\n    element: Dict[str, Any]\n    key: str\n    type: Literal[\"set\"] = \"set\"\n</code></pre>"},{"location":"modules/#routelit.domain.UpdateAction","title":"<code>UpdateAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to update the props of an element.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass UpdateAction(Action):\n    \"\"\"\n    The action to update the props of an element.\n    \"\"\"\n\n    props: Dict[str, Any]\n    key: str\n    type: Literal[\"update\"] = \"update\"\n</code></pre>"},{"location":"modules/#routelit.domain.ViewTaskDoneAction","title":"<code>ViewTaskDoneAction</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Action</code></p> <p>The action to mark that the task is done.</p> Source code in <code>src/routelit/domain.py</code> <pre><code>@dataclass\nclass ViewTaskDoneAction(Action):\n    \"\"\"\n    The action to mark that the task is done.\n    \"\"\"\n\n    type: Literal[\"task_done\"] = \"task_done\"\n</code></pre>"}]}